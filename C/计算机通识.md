# 冯诺依曼体系结构  
  

## 硬件  

## 中央处理器（CPU）
  
- 包括控制单元（control unit）与算术/逻辑单元（arithmetic/logic unit）  
- 每台计算机都有一内部时钟以固定速度发射电子脉冲，速度计量单位为**赫兹（Hz）、千兆赫（GHz）**  
	1kHz=1024Hz  
	1mHz=1024kHz  
	1GHz=1024mHz  
- 核（core）：实现指令读取与执行的部分  

CPU 内部包含寄存器等组件。在计算机体系结构中，CPU（中央处理器）是负责执行指令和处理数据的核心部件，而寄存器、缓存等是 CPU 内部的重要组成部分，它们共同协作以完成各种计算任务。以下是 CPU 内部主要组件的详细介绍：

### 寄存器

- **定义**：寄存器是 CPU 内部的一种高速存储单元，用于暂时存储数据、地址或其他控制信息。
- **作用**：
    - **指令寄存器（IR）**：用于存储当前正在执行的指令。
    - **程序计数器（PC）**：用于存储下一条指令的地址。
    - **通用寄存器**：用于存储操作数和中间结果，供 CPU 进行算术和逻辑运算。
    - **状态寄存器**：用于存储 CPU 的状态信息，如进位标志、零标志、溢出标志等。
- **特点**：寄存器的访问速度非常快，通常在 CPU 的一个时钟周期内就可以完成读写操作，但其存储容量相对较小，只有少数几个到几十个寄存器。

### 缓存

- **定义**：缓存是位于 CPU 和主存之间的一种高速存储器，用于暂时存储从主存中读取的数据和指令。
- **作用**：
    - **提高访问速度**：缓存的访问速度比主存快得多，当 CPU 需要访问数据时，如果数据已经在缓存中，CPU 可以直接从缓存中读取，从而减少等待时间。
    - **减少访问主存的次数**：通过缓存机制，可以减少 CPU 访问主存的次数，提高系统的整体性能。
- **类型**：
    - **一级缓存（L1 Cache）**：位于 CPU 内部，容量较小，速度最快，通常分为指令缓存和数据缓存。
    - **二级缓存（L2 Cache）**：可以位于 CPU 内部或外部，容量比一级缓存大，速度稍慢。
    - **三级缓存（L3 Cache）**：通常位于 CPU 外部，容量更大，速度较慢，用于进一步减少访问主存的次数。
        

### 其他组件

- **算术逻辑单元（ALU）**：负责进行算术和逻辑运算，如加法、减法、与、或、非等操作。
    
- **控制单元（CU）**：负责从内存中取出指令、解码指令，并产生相应的控制信号，以协调 CPU 内部各部件的工作。
    

总之，CPU 内部的寄存器、缓存等组件是其不可或缺的一部分，它们与 CPU 的内核协同工作，共同完成指令的执行和数据的处理。

## 架构

在计算机体系结构中，“架构” 是指计算机系统或组件的总体设计和组织结构，它定义了系统的功能特性和操作方式。对于内核（CPU 内核）来说，其架构是指内核内部的设计和组织方式，包括指令集、数据路径、控制单元、寄存器组织等各个方面。以下是关于内核架构的详细介绍：

### 指令集架构（ISA）

- **定义**：指令集架构是内核能够执行的指令集的定义，它规定了内核可以执行的基本操作和数据类型。
    
- **作用**：ISA 是软件和硬件之间的接口，编译器将高级语言编译成机器码，这些机器码必须符合内核的 ISA 才能被执行。
    
- **示例**：常见的 ISA 有 x86、ARM、RISC-V 等。Cortex-M3 内核使用的是 ARMv7-M ISA，它定义了内核可以执行的指令集，如数据处理指令、存储器访问指令、控制流指令等。
    

### 数据路径和控制单元

- **数据路径**：数据路径是指内核内部用于处理数据的组件和它们之间的连接方式，包括算术逻辑单元（ALU）、寄存器文件、乘法器等。
    
- **控制单元**：控制单元负责从内存中取出指令、解码指令，并产生相应的控制信号，以协调数据路径中各部件的工作，完成指令的执行。
    

### 寄存器组织

- **定义**：寄存器是内核内部的高速存储单元，用于暂时存储数据、地址或其他控制信息。
    
- **作用**：寄存器的组织方式影响内核的性能和编程模型，常见的寄存器包括通用寄存器、状态寄存器、程序计数器等。
    
- **示例**：Cortex-M3 内核拥有 8 个 32 位通用寄存器（r0-r7）、6 个 32 位专用寄存器（r8-r14）、1 个 32 位程序计数器（pc）和 1 个 32 位 xPSR 状态寄存器，这些寄存器为内核提供了丰富的临时存储空间，便于进行快速的数据处理。
    

### 总线接口

- **定义**：总线接口是内核与外部设备或存储器进行通信的通道，它定义了数据、地址和控制信号的传输方式。
    
- **作用**：总线接口的设计影响内核的访存速度和与外设的通信效率。
    
- **示例**：Cortex-M3 内核支持多种总线接口，如 AMBA APB、AMBA AHB 等，这些总线接口使得内核能够与片上存储器、外设等进行高效的数据传输。
    

### 内存管理单元（MMU）和缓存

- **内存管理单元（MMU）**：MMU 负责将虚拟地址映射到物理地址，支持操作系统的内存保护和虚拟内存管理功能。
    
- **缓存**：缓存是位于内核和主存之间的一种高速存储器，用于暂时存储从主存中读取的数据和指令，以减少访问主存的次数，提高系统的整体性能。
    
- **示例**：一些高端的内核（如 Cortex-A 系列）包含 MMU 和缓存，而 Cortex-M3 内核为了简化设计和降低成本，不包含 MMU 和缓存，但通过其他优化措施（如紧密耦合存储器 TCM）来提高性能。
    

总之，内核的架构决定了内核的功能特性、性能表现和编程模型，是计算机系统设计中的关键部分。对于 STM32 中的 Cortex-M3 内核，其架构设计使得它具有高性能、低功耗和低成本的特点，适合用于各种嵌入式应用场景。

### **存储设备**  

- 内存（断电时会丢失信息，但是读取速度快）  
- 磁盘（持久化存储设备）  
- 光驱（CD、DVD）  
- USB闪存驱动器  
  
#### **内存**  

*内存（Random-Access Memory,RAM）*
	由一有序的字节序列组成，用于存储程序及程序需要的顺序  
  

每一字节都有唯一地址，便于存储与获取数  


硬盘数据要加载到内存再被CPU读取  
  

单位：比特（bit）与字节（byte）  
  

- 一个0存储或一个1存储为一个比特，是计算机中最小的存储单位。  
- 1字节由8个比特构成，是计算机中最基本的存储单元  
- 计算机存储能力以字节来衡量：  
    - 1KB=1024B  
    - 1MB=1024KB  
    - 1GB=1024MB  
    - 1TB=1024GB  
  

### **输入与输出设备**  

键盘、鼠标、显示器、打印机……  

显示器屏幕分辨率：显示设备水平和垂直方向上显示的像素（px）数  

像素密度=sqrt(长度像素数^2 + 宽度像素数^2)/屏幕尺寸（屏幕对角线长度）  

### **通信设备**  
  
- 通过总线（bus）连接起来  
- 拨号调制解调器（用电话线）   
- DSL（数字用户线）（也是用电话线，但更快）  
- 电缆调制解调器（用有线电视电缆）  
- 网络接口卡（NIC）（将计算机接入局域网（LAN）的设备）  
- 无线网络（用无线适配器）  

## 软件  

### 操作系统（Operating System）  
  

是运行在计算机中最重要的程序，可以管理和控制计算机的活动  
  

### 万维网  
  
可以让web客户端访问web服务器上的页面，是一个由许多互相链接的超文本组成的系统，其中每个有用的事物称为一样 **资源**，由一个全局 **统一资源标识符（URI）** 标识，它们通过 **超文本传输协议（HTTP）** 传送给用户，后者通过点击链接来获得资源 

# 网络

两台电脑之间可以用网线连接起来，多台电脑间也可以用多条网线来连接起来，但这样有点麻烦，于是这里可以添置一个中间设备，所有电脑只需连接它然后使用这个中间设备来转发信息就行了，它就是 *集线器* 。

*集线器* 能将传入的数据包不做任何处理转发到所有出口，但这样就不能一对一通信了。解决方法是：给每台电脑起个名字（*Mac 地址*），然后发送数据包时在数据包前加上从哪里来到哪里去。这样一来，作为接收方的电脑看到信息不是给自己的就能忽略了。不过只是这样的话其他所有电脑还是能看到不属于自己的数据包，所以让这个集线器更智能一点，让信息只发送给目标电脑一个，它就变成了 *交换机* 。

交换机内部维护着一张 *Mac 地址表*，记录着每一个设备的 Mac 地址连接在哪个端口上。一开始的时候这张表时空的，交换机跟集线器没有区别，不过它会学习数据帧的源 MAC 地址来更新自己的表，这样之后就能正常工作了。

随着电脑数量越来越多，交换机的端口也不够用了。这是只要将多个交换机连接起来就行了，当然，另一个交换机所连接的所有设备对应的这个交换机的端口也就都是同一个。故虽然交换机的端口数量就会够用，但里面维护的 Mac 地址表确实是越来越大了，这样随着电脑数量的增多总有一天会出问题，这该怎么办呢？

这里的问题在于连到另一个交换机的那条线后面不知道有多少的设备连接进来，使得这张表越来越大，故可以让它接入一个新的设备，该设备拥有自己独立的 Mac 地址，还能帮我们做一次数据的转发，这个设备就是 *路由器* 。路由器的每个端口都有独立的 Mac 地址，这样只要往地址表中添加一条路由器地址与端口的映射关系数据就够了。而要将要发给另外一个交换机上的设备的所有信息先发给路由器又该怎么办呢？可以在 Mac 地址上做手脚（比如让一个交换机的设备的地址前几位统一），这样就可以根据地址来判断了。不过修改已有设备的 Mac 地址显然是不现实的：

*Mac 地址*
	也叫物理地址、硬件地址，长度为 48 位，其中前24位代表网络硬件制造商的编号，后面 24 位由厂家自行分配，一般表系列号。**一台设备的 Mac 地址在全世界范围内都是唯一的** 。

故我们尝试给电脑起一个新的随时能更改的名字，可以用一个 32 位的二进制编号，将它平均分为4部分，每部分用点相连，再将每部分转换为十进制，这就是 *ip 地址* 。这样就可以根据 ip 地址的前几位来判断是否要发给路由器了，然后之后的事就交给路由器。还要有一个机制用以将 ip 地址映射到 Mac 地址上，这个机制就是 *ARP 协议* ，每个设备中都会存一张 ARP 缓存表用以记录 ip 与 mac 地址的对应关系，这张表也像交换机中的那个表一样一开始空的然后经过一轮 ARP 请求才会往表中填东西。于是现在，一个数据包里除了要添加数据链路层头部信息（Mac 地址信息）之外，还要再加一个网络层的头部（ip 地址信息）。

这样一来，假如设备 A 的数据包要发给另一个交换机上的设备 B ，数据包的传输过程就像：
1. 先记录网络层头部信息，然后根据 ip 地址判断目标 Mac 地址——这里显然要传给路由器，于是就将路由器 Mac 地址写在数据链路层头部。
2. 数据包收到信息后，会根据 ip 地址修改数据链路层头部信息将目标 Mac 地址改为 B 的，然后将源 Mac 地址改为另一个端口的 Mac 地址，接着发出去。
3. 这样 B 就能接收到信息了。

这个过程中，A 判断是否通过路由器传输的根据就是 *子网* ，就是说若原 ip 与目标 ip 在同一子网就通过交换机发送出去，若不在一个子网就直接交给路由器。是否在同一子网就看 ip 地址前几位，也就是要使用 *子网掩码*  分别跟原 ip 和目标 ip 进行与运算，若结果相等则为同一子网。

A 要知道哪个设备是路由器，就要在 A 设置 *默认网关* 。*默认网关* 就是路由器端口的 ip 地址，当遇到不在同一个子网的电脑时，就将包先发到那里（这时设备 A 会查询默认网关的 mac 地址）。

路由器要实现继续将包往下传输的功能，就还需要一张 *路由表* ，存储地址范围与端口的对应关系。路由表中还可能会有 *下一跳地址* ，表示如果包不能直接传到目的地，可以再转交给下一个路由器来处理。

也就是说，网络层本身没有传输包的功能，包的实际传输是委托给数据链路层来实现的。交换机中有 Mac 地址表，路由器中有路由表，ARP 缓存表设备与路由器中都有。