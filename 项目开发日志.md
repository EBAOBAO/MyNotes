为方便合作，我在此记录我的负责部分的

# LoRa 模块

LoRa 模块使用串口与单片机连接，这个模块可以配置很多参数


# 气压传感器

- 只能用3.3v供电，不能用5v供电

![[BMP280电路连接.png]]

BMP280由压阻式压力传感元件和混合信号ASIC组成。ASIC执行A/D转换并提供转换结果和传感器特定 通过数字接口的补偿数据。

BMP280为设计人员提供了最高的灵活性，并可根据要求对精度，测量时间和功耗从高选择传感器设置的可能组合的数目中进行调整 。

BMP280 可以在三种功率模式下运行（参见第 3.6 章）：
- 睡眠模式
- 正常模式
- 强制模式

在睡眠模式下，不执行任何测量。正常模式包括自动活动测量周期和非活动待机周期之间的永久循环。在强制模式，则执行单次测量。测量完成后，传感器返回睡眠模式。

一组过采样设置范围从超低功耗到超高分辨率设置，以使传感器适应目标应用。该设置是预先设定的压力测量过采样和温度测量过采样的组合。压力和温度测量过采样可在0 ~ 16次过采样范围内独立选择（见3.3.1和3.3.2章）：

BMP280配备了一个内置的IIR滤波器，以尽量减少门或窗的开关引起的对输出数据的短期干扰， 滤波器系数范围为0（关）到16。

为了简化设备使用并减少大量可能的功率模式、过采样率和滤波器设置组合，Bosch Sensortec 提供了一套经过验证的针对智能手机、移动气象站或飞行玩具常见用例的建议
（见第 3.4 章）：

- 低功耗手持设备（例如运行 Android 的智能手机）
- 手持设备动态（例如运行 Android 的智能手机）
- 天气监测（具有最低功耗的设置）
- 电梯/楼层变化检测
- 跌落检测
- 室内导航

![[BMP280块图.png]]

内置了一个上电复位发生器，用于在开机序列之后复位逻辑电路和寄存器值。对 VDD 和 VDDIO 电平的上升斜率和顺序没有限制。上电后，传感器进入睡眠模式（见 3.6.1）。

警告。当 VDDIO 关闭时，若将任何接口引脚（SDI、SDO、SCK 或 CSB）保持在逻辑高电平状态，可能会因静电放电保护二极管中电流过大而永久损坏器件。

如果 VDDIO 有供电，但 VDD 没有供电，接口引脚将保持在高阻态。因此，在 BMP280 的 VDD 电源建立之前，总线就可以自由使用了。

BMP280测量周期包括温度和压力测量与可选的过采样。测量周期后，数据通过可选的IIR过滤器，该过滤器可消除压力的短期波动（例如，摔门引起的）。该流程如下图所示。

![[BMP280测量流程图.png]]

上面图表的各个模块将在以下章节中详细说明。

可以开启或跳过压力测量。如果使用BMP280作为温度传感器，跳过测量可能是有用的。启用后，存在几个过采样选项。每个过采样步骤减少噪声并将输出分辨率增加一位，这存储在XLSB数据寄存器0xF9中。通过控制寄存器0xF4中的osrs_p[2:0]位选择使能/禁用测量和过采样设置。

![[设置osrs_p.png]]

可以启用或跳过温度测量。跳过测量可以非常快速地测量压力。启用后，存在几个过采样选项。每个过采样步骤都可以减少噪声，并将输出分辨率提高一位，这将存储在XLSB数据寄存器0xFC中。通过控制寄存器0xF4中的osrs_t[2:0]位选择使能/禁用温度测量和过采样设置。（不要就设置为 000）

环境压力受到许多短期变化的影响，例如，砰地一声关上门或窗户，或风吹进传感器。为了在不引起额外接口流量和处理器工作负载的情况下抑制输出数据中的这些干扰，BMP280具有内部IIR滤波器。它有效地降低了输出信号的带宽。下一个测量步骤的输出是使用以下公式进行滤波：

$$
data filtered = \frac{datafilteredold \cdot (filter coefficien t - 1) \cdot dataADC}{filtercoeffecient}
$$

其中data_filtered_old是来自前一次采集的数据，data_ADC是来自IIR滤波之前的ADC的数据。

IIR滤波器可以使用控制寄存器0xF5中的滤波器[2:0]位配置，具有以下选项：

![[滤波器设置.png]]

当写入寄存器 *filter* 时，过滤器被重置。下一个值将通过过滤器，并成为过滤器的初始内存值。如果跳过温度或压力测量，即使输出寄存器设置为0x80000，相应的过滤器内存也将保持不变。当重新启用先前跳过的度量时，将使用上次未跳过度量时的筛选器内存对输出进行筛选。

（总之就是滤波器参数越高噪声越小）

噪声取决于所选的过采样和滤波器设置。所述值是在受控压力环境中确定的，基于以最高采样速度连续32个测量点的平均标准偏差。这是为了从噪声测量中排除长期漂移所必需的。

BMP280提供三种电源模式：睡眠模式、强制模式和正常模式。这些可以使用控制寄存器0xF4中的 *mode* \[1:0]位来选择。

```tx
| *mode*[1:0] | Mode |
| :--: | :--: |
| 00 | 睡眠模式 |
| 01 && 10 | 强制模式 |
| 11 | 正常模式 |
```

开机复位后，默认设置为休眠模式。在睡眠模式下，不执行任何测量，并且功耗（IDDSM）处于最低水平。所有寄存器都是可访问的；可以读取芯片id和补偿系数。

在强制模式下，根据所选的测量和滤波选项执行单个测量。当测量完成后，传感器返回到睡眠模式，测量结果可以从数据寄存器中获得。对于下一次测量，需要再次选择强制模式。这类似于BMP180的操作。对于采样率要求低或需要主机同步的应用，建议使用强制模式。

正常模式在（活动）测量周期和（非活动）待机周期之间连续循环，待机周期的时间由 $t_{standby}$定义。待机状态下的电流（IDDSB）略高于休眠状态。在设置了模式、测量和滤波选项后，就可以从数据寄存器中获得最后的测量结果，而不需要进一步的写访问。当使用IIR滤波器时，建议使用正常模式，对于需要过滤短期干扰（例如吹入传感器）的应用非常有用。

待机时间由控制寄存器0xF5中的t_sb[2:0]位的内容决定，如下表所示：

```tx
| t_sb[2:0] | tstandby [ms] |
| :--: | :--: |
| 000 | 0.5 |
| 001 | 62.5 |
| 010 | 125 |
| 011 | 250 |
| 100 | 500 |
| 101 | 1000 |
| 110 | 2000 |
| 111 | 4000 |
```

5.1 Interface selection 

接口选择根据 CSB （chip select） 状态自动完成。如果 CSB 连接到 VDDIO，则 I²C 接口处于活动状态。如果 CSB 下拉，则 SPI 接口被激活。在 CSB 被拉低一次后 （无论是否发生任何 clock cycle），I²C 接口被禁用，直到下一次上电复位。这样做是为了避免无意中将 SPI 流量作为 I²C 数据解码到另一个从设备。由于仅在 VDD 和 VDDIO 都建立时执行上电复位，因此不会因使用的上电序列而导致协议检测错误。但是，如果要使用 I²C，并且 CSB 不是直接连接到 VDDIO，而是通过可编程引脚连接，则必须确保该引脚在器件上电复位期间已经输出 VDDIO 电平。如果不是这种情况，该器件将被锁定在 SPI 模式，并且不响应 I²C 命令。

为了能够读取寄存器，首先必须以写模式发送寄存器地址（从地址111011x0）。 然后必须生成停止或重复启动条件。 之后，从机将以读取模式(RW='1')寻址到地址111011x1，然后从自动递增的寄存器地址发送数据，直到出现NOACKM和stop条件。 这如图8所示，其中从寄存器0xf6和0xf7读取两个字节。

# 角度/加速度传感器

使用了

# 同时读取多个模块/寄存器的数据

```c
uint8_t addr = 0x08;
for (; addr <= 0x77; addr++) {
	if (HAL_I2C_IsDeviceReady(&hi2c1, addr << 1, 3, 100) == HAL_OK)
	{
		HAL_UART_Transmit(&huart1, &addr, 1, HAL_MAX_DELAY);
	}
}
```

```c
typedef enum {
  SENSOR_NONE,
  SENSOR_BMP280_READING,
  SENSOR_JY901S_READING
} SensorState;

volatile SensorState current_sensor = SENSOR_NONE;
uint8_t bmp280_data[6];
uint8_t jy901s_data[9];

void Start_Sensor_Read() {
  current_sensor = SENSOR_BMP280_READING;
  HAL_I2C_Mem_Read_IT(&hi2c1, 0x76<<1, 0xF7, I2C_MEMADD_SIZE_8BIT, bmp280_data, 6);
}

void HAL_I2C_MemRxCpltCallback(I2C_HandleTypeDef *hi2c) {
  switch(current_sensor) {
    case SENSOR_BMP280_READING:
      // 处理BMP280数据
      Process_BMP280(bmp280_data);
      
      // 启动JY901S读取
      current_sensor = SENSOR_JY901S_READING;
      HAL_I2C_Mem_Read_IT(&hi2c1, 0x50<<1, 0x34, I2C_MEMADD_SIZE_8BIT, jy901s_data, 9);
      break;
      
    case SENSOR_JY901S_READING:
      // 处理JY901S数据
      Process_JY901S(jy901s_data);
      
      // 完成一轮读取
      current_sensor = SENSOR_NONE;
      
      // 可启动下一轮读取
      HAL_Delay(50);
      Start_Sensor_Read();
      break;
  }
}
```

```c
//其中dig_T1等就是上面的修正参数，adc_T,adc_p是从寄存器中读出的值。本程序作者有修改使其直接可用，但不对其准确性负责（数据手册里抄的，tnnd它也这样说，其实能用）
//返回值是有符号整数，单位是0.01摄氏度。若返回值为5123，则实际温度为51.23摄氏度
int32_t t_fine;
int32_t bmp280_compensate_T_int32(int32_t adc_T)
{
int32_t var1, var2, T;
var1 = ((((adc_T&gt;&gt;3) – ((int32_t)dig_T1&lt;&lt;1))) * ((int32_t)dig_T2)) &gt;&gt; 11;
var2 = (((((adc_T&gt;&gt;4) – ((int32_t)dig_T1)) * ((adc_T&gt;&gt;4) – ((int32_t)dig_T1))) &gt;&gt; 12) *((int32_t)dig_T3)) &gt;&gt; 14;
t_fine = var1 + var2;
T = (t_fine * 5 + 128) &gt;&gt; 8;
return T;
}
//返回值是无符号整数，单位为Pa，由24个整数位和8个小数位组成。若返回值为24674867，则真实值为24674867/256=96386.2Pa
uint32_t bmp280_compensate_P_int64(int32_t adc_P)
{
int64_t var1, var2, p;
var1 = ((int64_t)t_fine) – 128000;
var2 = var1 * var1 * (int64_t)dig_P6;
var2 = var2 + ((var1*(int64_t)dig_P5)&lt;&lt;17);
var2 = var2 + (((int64_t)dig_P4)&lt;&lt;35);
var1 = ((var1 * var1 * (int64_t)dig_P3)&gt;&gt;8) + ((var1 * (int64_t)dig_P2)&lt;&lt;12);
var1 = (((((int64_t)1)&lt;&lt;47)+var1))*((int64_t)dig_P1)&gt;&gt;33;
if (var1 == 0)
{
return 0; // avoid exception caused by division by zero
}
p = 1048576-adc_P;
p = (((p&lt;&lt;31)-var2)*3125)/var1;
var1 = (((int64_t)dig_P9) * (p&gt;&gt;13) * (p&gt;&gt;13)) &gt;&gt; 25;
var2 = (((int64_t)dig_P8) * p) &gt;&gt; 19;
p = ((p + var1 + var2) &gt;&gt; 8) + (((int64_t)dig_P7)&lt;&lt;4);
return (uint32_t)p;
```

```c
float BMP280_Compute_T(void)//实际温度和实际压强计算，就是数据手册的公式
{
  int32_t var1, var2,T;
  var1 = ((((BMP280.adc_T &gt;&gt; 3) - ((int32_t)BMP280.T1 &lt;&lt; 1))) *((int32_t)BMP280.T2)) &gt;&gt;11;
  var2 = (((((BMP280.adc_T &gt;&gt; 4) - ((int32_t)BMP280.T1)) *((BMP280.adc_T &gt;&gt; 4) - ((int32_t)BMP280.T1))) &gt;&gt;12) *((int32_t)BMP280.T3)) &gt;&gt;14;
  BMP280.t_fine = var1 + var2;
  T = (BMP280.t_fine * 5 + 128) &gt;&gt; 8;
  return (float)T/100;
}

float BMP280_Compute_P(void)
{
  BMP280_Compute_T();
  int64_t var1, var2, p;
  var1 = ((int64_t)BMP280.t_fine) - 128000;
  var2 = var1 * var1 * (int64_t)BMP280.P6;
  var2 = var2 + ((var1 * (int64_t)BMP280.P5) &lt;&lt; 17);
  var2 = var2 + (((int64_t)BMP280.P4) &lt;&lt; 35);
  var1 = ((var1 * var1 * (int64_t)BMP280.P3) &gt;&gt; 8) +((var1 * (int64_t)BMP280.P2) &lt;&lt; 12);
  var1 =(((((int64_t)1) &lt;&lt; 47) + var1)) * ((int64_t)BMP280.P1) &gt;&gt; 33;
  if (var1 == 0)
  {
    return 0;
  }
  else
  {
    p = 1048576 - BMP280.adc_P;
    p = (((p &lt;&lt; 31) - var2) * 3125) / var1;
    var1 = (((int64_t)BMP280.P9) * (p &gt;&gt; 13) * (p &gt;&gt; 13)) &gt;&gt; 25;
    var2 = (((int64_t)BMP280.P8) * p) &gt;&gt; 19;
    p = ((p + var1 + var2) &gt;&gt; 8) + (((int64_t)BMP280.P7) &lt;&lt; 4);
    return (float)p/256;
  }
}
```

```c
// 读取原始温度和压力数据
HAL_StatusTypeDef BMP280_ReadRawData(I2C_HandleTypeDef *hi2c, uint8_t address, int32_t *raw_temp, int32_t *raw_press) {
    uint8_t data[6];
    
    // 从0xF7读取6字节数据 (压力MSB/LSB/XLSB, 温度MSB/LSB/XLSB)
    if (HAL_I2C_Mem_Read(hi2c, address<<1, 0xF7, 1, data, 6, 100) != HAL_OK)
        return HAL_ERROR;
    
    // 组合压力数据 (20位)
    *raw_press = (int32_t)((data[0] << 12) | (data[1] << 4) | (data[2] >> 4));
    
    // 组合温度数据 (20位)
    *raw_temp = (int32_t)((data[3] << 12) | (data[4] << 4) | (data[5] >> 4));
    
    return HAL_OK;
}s
```

```c
typedef enum {
  SENSOR_NONE,
  SENSOR_A_READING,
  SENSOR_D_READING,
  SENSOR_P_READING
} SensorState;

static volatile SensorState current_sensor = SENSOR_NONE;
static uint8_t rxBuf[10];
static double A[3];
static double P;
static double D[3];
static char Message[256];
static uint8_t BMPAd = 0x76;
static uint8_t JYAd = 0x50;

void startSensorRead()
{   
	// 先读取角度
	current_sensor = SENSOR_D_READING;
    HAL_I2C_Mem_Read_IT(&hi2c1, JYAd<<1, 0x3D, I2C_MEMADD_SIZE_8BIT, rxBuf, 6);
}

HAL_StatusTypeDef BMP280_Init(I2C_HandleTypeDef *hi2c, uint8_t address) {
    uint8_t data;
    
    // 复位传感器
    uint8_t reset_cmd = 0xB6;
    HAL_I2C_Mem_Write(hi2c, address<<1, 0xE0, 1, &reset_cmd, 1, 100);
    HAL_Delay(10); // 等待复位完成
    
    // 配置模式: 温度x2, 压力x16, 正常模式
    data = 0x57; // 0b01010111
    HAL_I2C_Mem_Write(hi2c, address<<1, 0xF4, 1, &data, 1, 100);
    
    // 配置滤波器: IIR系数16
    data = 0x10; // 0b00010000
    return HAL_I2C_Mem_Write(hi2c, address<<1, 0xF5, 1, &data, 1, 100);
}

HAL_StatusTypeDef JY901S_Init(I2C_HandleTypeDef *hi2c, uint8_t address)
{
	uint8_t data[] = {0x88, 0xB5};
	strcpy(Message, "开始将xy轴角度置零\n");
	HAL_UART_Transmit(&huart1, (uint8_t *)Message, strlen(Message), HAL_MAX_DELAY);
	HAL_I2C_Mem_Write(hi2c, address<<1, 0x69, 1, data, 2, 100);
	HAL_Delay(200);
	data[0] = 0x08;
	data[1] = 0x00;
	HAL_I2C_Mem_Write(hi2c, address<<1, 0x01, 1, data, 2, 100);
	HAL_Delay(3000);
	strcpy(Message, "角度置零结束，开始校准加速度\n");
	HAL_UART_Transmit(&huart1, (uint8_t *)Message, strlen(Message), 100);
	data[0] = 0x01;
	data[1] = 0x00;
	HAL_I2C_Mem_Write(hi2c, address<<1, 0x01, 1, data, 2, 100);
	HAL_Delay(4000);
	data[0] = 0x00;
	data[1] = 0x00;
	HAL_I2C_Mem_Write(hi2c, address<<1, 0x01, 1, data, 2, 100);
	HAL_Delay(100);
	strcpy(Message, "校准加速度结束\n");
	HAL_UART_Transmit(&huart1, (uint8_t *)Message, strlen(Message), 100);
	data[0] = 0x00;
	data[1] = 0x00;
	return HAL_I2C_Mem_Write(hi2c, address<<1, 0x00, 1, data, 2, 100);
}

void Process_D(uint8_t *rxData)
{
	// 单位为度
	D[0] = (double)((rxBuf[1] << 8 | rxBuf[0]) / 32768 * 180);
	D[1] = (double)((rxBuf[3] << 8 | rxBuf[2]) / 32768 * 180);
	D[2] = (double)((rxBuf[5] << 8 | rxBuf[4]) / 32768 * 180); 
}

void Process_A(uint8_t *rxData)
{
	A[0] = (double)((rxBuf[1] << 8 | rxBuf[0]) / 32768 * 16 * 9.8);
	A[1] = (double)((rxBuf[3] << 8 | rxBuf[2]) / 32768 * 16 * 9.8);
	A[2] = (double)((rxBuf[5] << 8 | rxBuf[4]) / 32768 * 16 * 9.8); 
}

void Process_P(uint8_t *rxData)
{
	int32_t raw_press = (int32_t)((rxData[0] << 12) | (rxData[1] << 4) | (rxData[2] >> 4));
	int32_t raw_temp = (int32_t)((rxData[3] << 12) | (rxData[4] << 4) | (rxData[5] >> 4));
	
	int32_t var1, var2;
	
	var1 = ((((raw_temp >> 3) - ((int32_t)calib.dig_T1 << 1))) *((int32_t)calib.dig_T2)) >> 11;
	var2 = (((((raw_temp >> 4) - ((int32_t)calib.dig_T1)) *((raw_temp >> 4) - ((int32_t)calib.dig_T1))) >> 12) *((int32_t)calib.dig_T3)) >> 14;
	int32_t t_fine = var1 + var2;
	
	int64_t var3, var4, p;
	var3 = ((int64_t)t_fine) - 128000;
	var4 = var3 * var3 * (int64_t)calib.dig_P6;
	var4 = var4 + ((var3 * (int64_t)calib.dig_P5) << 17);
	var4 = var4 + (((int64_t)calib.dig_P4) << 35);
	var3 = ((var3 * var3 * (int64_t)calib.dig_P3) >> 8) +((var3 * (int64_t)calib.dig_P2) << 12);
	var3 =(((((int64_t)1) << 47) + var3)) * ((int64_t)calib.dig_P1) >> 33;
	if (var3 == 0)
	{
		P = 0;
	}
	else
	{
		p = 1048576 - raw_press;
		p = (((p << 31) - var4) * 3125) / var3;
		var3 = (((int64_t)calib.dig_P9) * (p >> 13) * (p >> 13)) >> 25;
		var4 = (((int64_t)calib.dig_P8) * p) >> 19;
		p = ((p + var3 + var4) >> 8) + (((int64_t)calib.dig_P7) << 4);
		P = (double)p / 256;
	}
}

void HAL_I2C_MemRxCpltCallback(I2C_HandleTypeDef *hi2c)
{
	switch (current_sensor)
	{
		case SENSOR_D_READING:
			Process_D(rxBuf);
			current_sensor = SENSOR_A_READING;
			HAL_I2C_Mem_Read_IT(&hi2c1, JYAd<<1, 0x34, I2C_MEMADD_SIZE_8BIT, rxBuf, 6);
			break;
		case SENSOR_A_READING:
			Process_A(rxBuf);
			current_sensor = SENSOR_P_READING;
			// 从0xF7读取6字节数据 (压力MSB/LSB/XLSB, 温度MSB/LSB/XLSB)
			HAL_I2C_Mem_Read_IT(&hi2c1, BMPAd<<1, 0xF7, I2C_MEMADD_SIZE_8BIT, rxBuf, 6);
			break;
		case SENSOR_P_READING:
			Process_P(rxBuf);
			snprintf(Message, sizeof(Message), "%f/%f/%f/%f/%f/%f/%f\n", D[0], D[1], D[2], A[0], A[1], A[2], P);
			HAL_UART_Transmit_IT(&huart1, (uint8_t *)Message, strlen(Message));
			break;
		case SENSOR_NONE:
			break;
	}
}

if (JY901S_Init(&hi2c1, JYAd) == HAL_OK)
{
  strcpy(Message, "JY901初始化完成\n");
  HAL_UART_Transmit(&huart1, (uint8_t *)Message, strlen(Message), 100);
}
if (BMP280_Init(&hi2c1, BMPAd) == HAL_OK)
{
  strcpy(Message, "BMP280初始化完成\n");
  HAL_UART_Transmit(&huart1, (uint8_t *)Message, strlen(Message), 100);
}
BMP280_ReadCalibration(&hi2c1, BMPAd);
strcpy(Message, "校准参数读取完成\n");
HAL_UART_Transmit(&huart1, (uint8_t *)Message, strlen(Message), 100);
```

# 姿态角测算

# 后续优化目标

