
# 写在前面……

## 本笔记的目的

自程序设计课开课以来，C 语言就使广大学子焦头烂额、寝食难安，生灵有倒悬之急，苍生饱受涂炭之苦。在这样的危急关头，本人临危就命，励志写下一篇宇宙无敌超级第一的 C 语言笔记，造福全人类！

……于是，这篇笔记就这么诞生了（

认真地说，本人素来对编程有着很大的兴趣，在编程方面独自摸索已有好几年，对 c、python、java 语言都略懂点皮毛，但也由于本人不善于寻找学习资源且从来没有同好交流，故学习过程中常常踩坑，学习效率也及其低下。不过正所谓“前人栽树，后人乘凉”，倘若我多花点时间搜寻信息解决问题就能帮助其他的同好免去这桩麻烦事，这倒也是好事一桩，故我也就有将自己的经验记录下来做成一篇笔记的想法，希望能对跟我遇到了同样问题的学习者提供或多或少的帮助，顺便也能够让我借由本笔记的宣传而得以与更多的同好交流！

## 引用内容来源

我是说本笔记的写作目的在于记录本人的学习经验，不过更为根本的目的是帮助各位读者的学习，故我也希望本笔记在我没有碰到什么问题的地方也有详细的记录，这样一是可以帮助到更多比如对编程语言完全没有概念的 0 基础的学习者，二也能让本笔记的内容形成一个完整的体系从而让我的这些零碎的经验能够更好地被整合到一起。不过要达到这个目的就会有一个问题，就是对于一些内容我能掌握但是却难以教给别人，就比如一些很基础的诸如函数之类的东西，所以事实上比起让我一个毫无教育经验甚至不善于社交的人来亲自写一篇类似于教程之类的东西，我想在涉及到那些部分时直接照抄现有的教程或让 ai 生成内容会让各位更易于理解（所以这也是为什么我说这是篇“笔记”而不是什么“教程”或”讲义“的原因——照抄我的老师说过的话，再结合自己经验和理解进行补充，“笔记”不就是这么回事吗？），不过请各位放心，那些我认为不算是基础的内容基本都是我原创的，我引用别人教程内容的目的只有两个，一是保证内容结构完整，二是获得更易于理解的表述。

故此，我想我应当在此声明一下，本篇笔记中基础部分绝大部分内容以及组织起所有内容的整体框架源于这里 -> [C 语言教程 菜鸟教程](https://www.runoob.com/cprogramming/c-tutorial.html)，另外还有网上找的各路的教程、博客之类的，还有就是 AI 生成的一些内容了（这些内容我肯定不会完全照抄的，多少会有点改动，就是细品后感觉还会留点 AI 味），一些琐碎的引用内容出处我就不在此一一列举了，反正你在网上找到有相似内容的文章之类的东西的话，我大概率就是从那里抄的。

## 食用方法

说老实话，我个人认为 C 语言的学习主要不是往 “广” 了学的，而是往 “深” 了学的，因为就其表面来看，C 语言没什么东西，它没有什么各种诸如 “泛型” “线程” 之类的概念，甚至没有面向对象的相关内容。它是个很基础的语言，学它会越来越往诸如编译原理这样底层的方面去学。事实上，本笔记总体也就是遵循这样的逻辑进行编排：先向你介绍一些东西的语法和它的举例应用，再回过头解释一些更为底层的东西让你对它有深入的理解。我个人比较喜欢这样的编排方式，就像先用具体的例子引出一些数学公式或定理，告诉你它大概是怎么用的，让你形成某种直觉，然后再详细地证明它或是介绍更多的细节，而不是一开始就莫名其妙抛给你一大堆公式定理和它们冗长的证明和什么引理，让人在学的过程中就想为什么我要知道这些东西从而无法抓住内容的重点。**如果你是一名初学者，我也推荐你就按照我的编排循序进行学习！**

而且语言嘛，你知道的，里面各种概念其实彼此间都有联系，众多概念交织成一张网，当我在介绍一个概念时，你可能尚且会遇到很多问题，不过相信我，大部分问题会随着学习的进展而解决。**当你难以理解某部分内容时，也许不必一直在那里死磕，跳过它了解更多东西后再回头看它，你就会对它有更多的认识！**

## 最后……

正如我上文所言，我实在很希望这篇笔记能够成为一篇详尽的笔记以帮助广大 C 语言学习者，不过我个人水平其实也十分有限，故这篇笔记后续也肯定会有要添加与要修改的内容，这也是为什么我莫名其妙的要给这篇笔记加版本号的原因。欢迎所有看到这篇笔记的人来同我交流讨论本笔记相关内容，我的邮箱是 76200818@qq.com，我很乐意尽可能地修改这篇笔记让它真的成为 “宇宙无敌超级第一 C 笔记” ！

# 环境配置

为了学习 c 语言，你需要一些东西来运行自己的代码。你可以在网上搜索并使用c语言在线编辑器。不过让程序在线运行肯定是不如让它在本地运行的。要使用任何计算机语言进行开发，没人会使用在线编辑器，它跟自己搭建的开发环境完全就是两码事。虽然学习阶段这方面比较无所谓，但我还是推荐你去在自己的电脑上配置一个开发环境。

……话是这么说的，不过本笔记主要侧重对c语言学习的讨论，对c语言环境的配置在此不会有特别详细的记录——我会直接给出一个在这方面有详细叙述的文章的链接：

[从零开始的vscode安装及环境配置教程(C/C++)(Windows系统)_vscode搭建编译器环境-CSDN博客](https://blog.csdn.net/qq_45807140/article/details/112862592)

我本人一直在使用 vscode 来学 c 。跟专门写 c 的集成开发环境相比，vscode 十分轻量，配置不高的电脑也带得动；而跟普通的文本编辑器相比，它又可以轻松的安装各种插件，使其有强大的功能，所以我也推荐各位使用 vscode ！

上面那篇文章是我目前能找到的最为简单的的配置过程了，我想各位按着它来应该就不会踩什么坑，请放心食用。

过去学习 c++ 时，我使用的是 dev-c++，运行程序会弹出来一个小黑框，然后输出就是在那里输出的，也就是上面这篇文章的文末所提及的把 *launch.json* 文件中 "externalConsole" 项目的值改为 “true” 之后运行程序会发生的现象（外部控制台输出），不过这样会有一个问题，那就是输出中文时会出现乱码：

![pESxYTI.png](https://s21.ax1x.com/2025/01/02/pESxYTI.png)


这是由于 Windows 系统下默认控制台编码格式为936(ANSI/OEM - 简体中文 GBK)，而C程序文件默认编码格式为 utf-8 ，由于编码格式不一致，导致程序运行时会出现中文乱码的情况。

解决方法就是直接修改源代码，增添头文件 `<windows.h>` 和调用API函数SetConsoleOutputCP(65001)，设置控制台程序输出的代码页编码为utf-8格式

![pESxJ0A.png](https://s21.ax1x.com/2025/01/02/pESxJ0A.png)



# Hello World!

```c
#include<stdio.h>

int main()
{
    printf("Hello World! \n");
    return 0;
}
```

一个 C 程序主要包括以下部分：

-   预处理器指令：如 `#include` 和 `#define`。
-   函数（每个 C 程序都至少有一个 `main()` 函数）
-   变量
-   语句 & 表达式
-   注释

让我们据此分析一下上面这段程序：

1.  程序的第一行 `#include <stdio.h>` 是预处理器指令，告诉 C 编译器在实际编译之前要包含 `stdio.h` 文件。
2.  下一行 `int main()` 是主函数，程序从这里开始执行。
3.  像 `/*...*/` 这样的语句将会被编译器忽略，这里放置程序的注释内容。它们被称为程序的注释。
4.  下一行 `printf(...)` 是 C 中另一个可用的函数，会在屏幕上显示消息 "Hello, World!"。
5.  下一行 `return 0;` 终止 `main()` 函数，并返回值 0。

今后我们写程序时，基本上都会把语句放到  `main` 函数里面，也就是说，在那个花括号中，且在`return 0` 之前写。

## 编译 & 执行 C 程序

接下来让我们看看如何把源代码保存在一个文件中，以及如何编译并运行它。下面是简单的步骤（对Linux 系统来说）：

1.  打开一个文本编辑器，添加上述代码。
2.  保存文件为 _hello.c_。
3.  打开命令提示符，进入到保存文件所在的目录。（或在保存文件所在的目录处输入“cmd”并回车）

![cmd](https://s21.ax1x.com/2025/01/02/pESxB6g.png)

4.  现在应该会弹出来一个小黑框，在其中键入 `gcc hello.c`，输入回车，编译代码。
5.  如果代码中没有错误，命令提示符会跳到下一行，并生成 _a.out（ **Windows 生成 a.exe**）_ 可执行文件。
6.  现在，键入 `a.out` （或 `a.exe` ）来执行程序。
7.  您可以看到屏幕上显示 _"Hello World"_。

```bash
$ gcc hello.c
$ ./a.out
Hello, World!
```

请确保您的路径中已包含 gcc 编译器，并确保在包含源文件 hello.c 的目录中运行它。

如果是多个 c 代码的源码文件，编译方法如下（这里是 Linux 的编译方法，windows 只要将 *main.out* 改为 *main.exe* 就可以了）：

```bash
$ gcc test1.c test2.c -o main.out
$ ./main.out
```

不过，如果你按上面的教程配置过 vs code了，那直接在 vs code 按 <kbd> f5 </kbd> 即可调试， <kbd> ctrl + f5 </kbd> 运行。

我们刚才编译运行 c 程序时使用的就是 Windows 系统自带的 **CMD** 终端，下面有一些帮你了解终端的拓展内容，不过它跟 C 语言本体的学习关系不大，初学者及不感兴趣者完全可以跳过（我就没怎么学过，说老实话以下部分内容基本上是ai生成的，姑且记录一下，初学可以考虑跳过）。

（跳过部分由此开始↓）

---

### 拓展1：windows 终端

**命令行解释器** 也被称为命令行界面或终端（Terminal），它就是一个用于与计算机系统交互的界面，它允许用户通过输入文本命令来控制系统。终端可以是物理设备，也可以是软件程序，它们提供了命令行界面（CLI），用户可以在其中输入和执行命令。

你可以把终端想象成一个会说话、能听懂你命令的智能助手。当你打开终端窗口，就可以开始和它对话，告诉它你想要做什么。

Windows 系统自带的终端叫做命令提示符（Command Prompt），简称 CMD。它是一个基于文本的界面，允许用户输入命令来执行各种任务，比如管理文件和文件夹、运行程序、配置系统设置等。

CMD 支持一些基本的批处理脚本，这些脚本文件通常以 `.bat` 或 `.cmd` 扩展名保存。批处理脚本包含一系列命令，你可以一次性运行这些命令，而不需要逐个手动输入。

例如，一个简单的批处理脚本可能看起来像这样：

```batch
@echo off
echo 正在复制文件...
copy C:\source\file.txt C:\destination\
echo 文件复制完成。
```

这个脚本会关闭命令的回显（`@echo off`），打印一条消息（`echo 正在复制文件...`），然后复制一个文件（`copy C:\source\file.txt C:\destination\`），最后打印另一条消息（`echo 文件复制完成。`）。

批处理脚本的基本组成如下：

1. 命令：CMD 支持一系列的内部命令，比如 `echo`（显示文本）、`dir`（列出目录内容）、`copy`（复制文件）、`del`（删除文件）等。
    
2. 参数： 命令后面可以跟参数，这些参数会影响命令的行为。比如 `copy source.txt destination.txt` 会复制文件。
    
3. 变量：批处理脚本可以定义和使用变量。变量可以用来存储数据，比如文件路径、用户输入等。
    
4. 控制流：批处理脚本支持基本的控制流结构，如 `if` 条件判断、`for` 循环等。
    
5. 注释：批处理脚本使用 `REM` 或 `::` 来添加注释，注释不会被脚本执行，通常用于解释脚本的功能。

一个简单的批处理脚本示例：

```batch
@echo off
echo Hello, this is a test script.
set /p name=Please enter your name:
echo Welcome, %name%!
copy C:\source\file.txt C:\destination\
if exist C:\destination\file.txt (
    echo File copied successfully.
) else (
    echo File copy failed.
)
```

这个脚本做了以下几件事：

-   `@echo off` 关闭命令的回显，使得执行时不会显示每条命令。
-   `echo Hello, this is a test script.` 显示一条欢迎信息。
-   `set /p name=Please enter your name:` 提示用户输入名字，并将输入存储在变量 `name` 中。
-   `echo Welcome, %name%!` 显示欢迎信息，并包含用户输入的名字。
-   `copy C:\source\file.txt C:\destination\` 复制文件。
-   `if exist C:\destination\file.txt` 检查文件是否成功复制。
-   `echo File copied successfully.` 和 `echo File copy failed.` 根据文件是否成功复制，显示不同的信息。

要运行这个脚本，你可以将其保存为 `.bat` 或 `.cmd` 文件，然后在CMD中输入文件名来执行。批处理脚本虽然功能有限，但对于简单的自动化任务来说是非常方便的。

除了命令提示符，Windows 还有一个更现代的终端叫做 PowerShell。PowerShell 是一个功能更强大的命令行环境，它支持更复杂的脚本编写，使用一种名为 PowerShell 脚本（.ps1 文件）的脚本语言。PowerShell 脚本功能丰富，可以进行更复杂的系统管理和自动化任务。

例如，一个简单的 PowerShell 脚本可能看起来像这样：

```powershell
Write-Host "正在复制文件..."
Copy-Item -Path "C:\source\file.txt" -Destination "C:\destination\"
Write-Host "文件复制完成。"
```

这个脚本会打印一条消息，复制一个文件，然后打印另一条消息。PowerShell 脚本使用 cmdlet（如 `Write-Host` 和 `Copy-Item`）来执行操作，这些 cmdlet 是 PowerShell 环境中的命令。

CMD和PowerShell有以下主要区别：

1.  历史和发展
    
    CMD 是Windows的传统命令行解释器，它的设计基于MS-DOS操作系统。PowerShell 是一个较新的命令行环境，由微软在2006年发布，它基于 .NET Framework 构建，设计目标是提供更强大的脚本编写和自动化功能。
2.  脚本语言
    
    CMD 支持简单的批处理脚本，这些脚本通常用于执行一系列命令，但功能有限。PowerShell 使用一种名为PowerShell脚本语言，它功能强大且灵活，支持复杂的脚本和自动化任务。PowerShell脚本可以访问 .NET Framework 中的类和方法，这使得它在功能上远远超过了CMD。
3.  命令和功能
    
    CMD 提供了一些基本的命令来管理文件系统、网络、进程等。PowerShell 提供了大量的cmdlet（命令），这些cmdlet可以用来执行各种管理任务，包括文件系统管理、网络管理、系统配置、远程管理等。PowerShell的cmdlet设计使得它们可以轻松地组合使用，以实现更复杂的功能。
4.  对象处理能力
    
    CMD 主要处理文本输出，PowerShell 处理的是对象。这意味着PowerShell可以更容易地操作和传递数据，因为它使用.NET对象而不是简单的文本。
5.  远程管理
    
    CMD 支持一些基本的远程命令执行，但功能有限。PowerShell 提供了强大的远程管理功能，允许管理员执行跨网络的命令和脚本。
6.  可扩展性
    
    CMD 的可扩展性有限，它主要用于执行简单的命令和批处理脚本。PowerShell 可以通过自定义cmdlet、函数、模块等方式进行扩展，这使得它可以根据需要进行定制和扩展。
7.  用户界面
    
    CMD 有一个简单的文本界面，功能较为有限。PowerShell 提供了一个更现代的界面，支持语法高亮、自动完成、多标签等功能，使得脚本编写和调试更加方便。

总的来说，PowerShell是一个更先进、功能更强大的命令行环境，它提供了更多的命令、更好的脚本编写能力以及更广泛的自动化选项。随着Windows系统的更新和发展，微软也在逐渐推动PowerShell作为主要的命令行工具。

### 拓展2：bash

Bash 是 "Bourne Again SHell" 的缩写，它也是一个命令行解释器，用于与计算机操作系统进行交互。Bash 是大多数 Linux 系统和 macOS 系统中的默认 shell，也被许多用户安装在 Windows 系统上。

Bash 不仅仅是一个命令行解释器，它还是一个强大的脚本语言。你可以编写一系列的命令，将它们保存到一个文件中，然后运行这个文件来执行这些命令。这种脚本通常用于自动化任务，比如批量处理文件、运行程序、管理系统任务等。

举个例子，你可以创建一个名为 `backup.sh` 的文件，里面包含以下内容：

```bash
#!/bin/bash
# 一个简单的备份脚本

# 定义备份文件的名称
backup_filename="backup_$(date +%Y%m%d).tar.gz"

# 创建一个备份
tar -czf $backup_filename /path/to/directory

# 打印完成信息
echo "备份完成：$backup_filename"
```

这个脚本会创建一个压缩的备份文件，包含 `/path/to/directory` 目录下的所有内容。然后，你可以通过在终端中输入 `./backup.sh` 来运行这个脚本。

Bash 的强大之处在于它的灵活性和简洁性，它允许你快速执行复杂的命令序列，并且可以通过编写脚本来自动化许多日常任务。

---

（跳过部分到这里结束↑）

## 代码规范

**代码规范** 是一套指导程序员编写代码的规则和标准，它的目的是提高代码的可读性、可维护性和一致性，**简单地说，遵循代码规范就能让你的写的程序更加好看，易懂**。

这是许多跟着老师学的编程学习者会忽略的一样东西——至少我身边大多数人如此，他们在看我打代码时往往就会问出“为什么要在等号两边加空格”这样的问题，毕竟只要代码能运行，谁会管它好不好看呢？老师也不会向我们强调这些，甚至都根本不会提到 “代码规范” 这个词，因为他的职责也仅止于让我们能写出可运行的代码，使我们通过课业，而且对于大多数人而言程序也确实只是可运行即可。尽管如此，我还是认为它的重要性再怎么强调也不为过！我们说代码应当具有 “可读性” ，确实如此：编程语言被称为 “语言" ，而语言就是用来便于我们交流的东西，你想让机器执行什么，不仅机器要看懂，人也要看懂，如果程序只是可运行即可，那我们为什么不沿袭上古程序员的传统，用二进制机器码写东西呢？我想，像 C 语言这样的语言被开发出来的目的也就只有两个：一是要让人能更轻松地写出程序，二就是为了要让人能更轻松地看懂程序！往现实了说，就算你不是一名开发者，你自己想写点东西出来时也不可避免的会遇到要跟其他人一起写代码或交流代码的情况，如果你的代码乱七八糟，随便缩进，乱起变量名还不写注释，别说别人，过几天你自己都会很难看懂你写的东西，如果你的程序之后出了什么bug，我敢肯定你自己都改不了一点！

**所以，不管你学什么语言，代码规范都是很重要的东西！** 如果你是一名初学者的话，遵守代码规范，养成良好的编程习惯，这对你的帮助绝对不亚于学习任何其他的 “编程技巧” 之类的东西！

当然，C 语言的代码规范学习起来也并不是什么难事。我们主要要注意的东西也不多：

首先是要注意程序中的一些 “空白”，这些 “空白” 不会浪费内存，虽然会让你多打些东西，但是值得：

1. 定义变量后要空行。尽可能在定义变量的同时初始化该变量，即遵循就近原则。如果变量的引用和定义相隔比较远，那么变量的初始化就很容易被忘记。若引用了未被初始化的变量，就会导致程序出错。
2. 每个函数定义结束之后都要加空行。
3. 关键字之后要留空格。像 const、case 等关键字之后至少要留一个空格，否则无法辨析关键字。像 if、for、while 等关键字之后应留一个空格再跟左括号`(`，以突出关键字。
4. 函数名之后不要留空格，应紧跟左括号`(`，以与关键字区别。
5. `(`后不留空格；`)`、`,`、`;`这三个前不留空格。
6.  `,`之后要留空格。如果`;`不是一行的结束符号，其后要留空格。
7. 赋值运算符、关系运算符、算术运算符、逻辑运算符、位运算符等双目运算符的前后（等号两边，加减乘除号两边之类的）应当加空格。
8. 单目运算符 !、~、++、--、－（负号）、*（指针）、&（取地址） 等前后不加空格。
9. 像数组符号`[]`、结构体成员运算符`.`、指向结构体成员运算符`->`，这类操作符前后不加空格。
10. 对于表达式比较长的 for 语句和 if 语句，为了紧凑起见，可以适当地去掉一些空格。但 for 和 if 后面紧跟的空格不可以删，其后面的语句可以根据语句的长度适当地去掉一些空格。例如 `for (i=0; i<10; i++)` for 和分号后面保留空格就可以了，`=`和`<`前后的空格可去掉。 
11. 缩进是通过键盘上的 Tab 键实现的，长度与四个空格一样。原则是：如果地位相等，则不需要缩进；如果属于某一个代码的内部代码就需要缩进。
12. `{`和`}`分别都要独占一行。互为一对的`{`和`}`要位于同一列，并且与引用它们的语句左对齐，或者 `{` 也可以写到相关语句加一个空格后。

***（如果你懒得写这些空行之类的玩意的话，VScode 中按 <kbd>shift + alt + F</kbd> 快捷键就能自动格式化代码。其他集成开发环境也大多会有这个功能的快捷键，可以在网上查一下。）***

其次是一些命名规范：

1. 变量名函数名之类的最好有明确含义。
2. 最好别使用单词缩写和汉语拼音，要用英语单词（不会网上查）。
3. 变量名和函数名应该使用小写字母，单词之间使用下划线分隔（例如 `my_variable`）。
4. 宏定义和常量应该全部大写（例如 `MAX_SIZE`）。
5. 类型定义（typedef）和结构体名称应该首字母大写（例如 `struct MyStruct`）。

再就是关于写语句的：

1. 每行代码不超过80个字符，以便于阅读。
2. 避免函数过长，新增函数不超过 50 行 （非空非注释行）。
3. 一行代码最好只做一件事情，如只定义一个变量，或只写一条语句。这样的代码容易阅读，并且便于写注释。
4. 将相关的函数和变量组织在一起。
5. 尽量避免使用全局变量，如果必须使用，应该有明确的注释说明其用途。
6. 使用结构体来组织复杂的数据。

最后是关于写注释的：

1. 每个文件的开头都应有注释，说明文件的功能和作者。
2. 函数的定义之前应有注释，说明函数的功能、参数和返回值。
3. 复杂的代码块应有注释，解释其工作原理。
4. 使用 `/* ... */` 进行多行注释，使用 `//` 进行单行注释。
5. 注释是对代码的“提示”，而不是文档。程序中的注释不可喧宾夺主，注释太多会让人眼花缭乱。
6. 如果代码本来就是清楚的，则不必加注释。例如 `i++; //i加1` 这个就是多余的注释。
7. 边写代码边注释，修改代码的同时要修改相应的注释，以保证注释与代码的一致性，不再有用的注释要删除。
8. 当代码比较长，特别是有多重嵌套的时候，应当在段落的结束处加注释，这样便于阅读。
9. 每一条宏定义的右边必须要有注释，说明其作用。

说老实话，代码规范虽然确实重要，不过也不必太过严格地遵守这些规则，我记录这些内容的主要目的就是提醒各位应该在程序的可读性上多留个心眼。这里事实上也只是粗略地记录一下主要的内容，网上也有更多更详尽的内容供你了解。

（姑且贴一篇文章：[华为C语言编程规范（精华总结）](https://blog.csdn.net/m0_38106923/article/details/105042594)）

为了让代码易读，易维护，除了代码规范之外还有什么类似于 “设计原则” “设计模式” 之类的玩意，你可以去了解一下。这些东西并不算是十分基础，我之后可能会添加这些内容，不过也许对于名为 "Hello World" 的一章而言我想我们最好该就此打住了。

# C 基本语法

## C 的令牌

在C语言中，一个程序的各个部分就是由 **“令牌（Token）”** 构成的。令牌这个词可能听起来有点复杂，但其实它的概念并不难理解。我们可以把它想象成拼图游戏或者积木游戏中的一块块拼图或积木，在C语言中，编程就像是在玩一个大型的拼图游戏，你需要把不同的“令牌”拼在一起，来创建一个程序。

在C语言中，“令牌”主要有以下几种：

1.  **关键字**：它们有特殊的意义。比如“int”代表整数，“if”代表如果某个条件成立。
    
2.  **标识符**：它们用来给变量或函数命名，比如“x”或“calculate”。
    
3.  **字面量**：它们代表具体的数值，比如“5”或“3.14”。
    
4.  **运算符**：它们用来表示操作，比如“+”代表加法，“-”代表减法。
    
5.  **分隔符**：它们用来分隔不同的部分，比如“;”（分号）用来结束一条语句。
    

当你编写C语言程序时，你就是在把这些“令牌”按照正确的顺序和规则拼在一起，让计算机能够理解并执行你的指令。就像拼图游戏需要按照正确的图案来拼，编程也需要按照C语言的规则来使用这些“令牌”。如果拼错了，程序可能就不会正常工作，就像拼图拼错了图案一样。

先来大致介绍一下令牌之中较简单的部分：

## 分隔符

在 C 中，空格分隔语句的各个部分，让编译器能识别语句中的某个元素（比如 int）在哪里结束，下一个元素在哪里开始。因此，在下面的语句中：

```c
int age;
```

在这里，int 和 age 之间必须至少有一个空格字符（通常是一个空白符），这样编译器才能够区分它们。另一方面，在下面的语句中：

```c
fruit = apples + oranges;   // 获取水果的总数
```

fruit 和 =，或者 = 和 apples 之间的空格字符不是必需的，但是为了增强可读性，您可以根据需要适当增加一些空格（详见前文 *代码规范*）。

只包含空格的行，被称为空白行，C 编译器会完全忽略它。

在 C 程序中，分号是语句结束符。也就是说，每个语句必须以分号结束。它表明一个逻辑实体的结束。

例如，下面是两个不同的语句：

```c
printf("Hello, World! \n");
return 0;
```

另外分割符还有逗号 `,` ，逗号运算符用于分隔表达式列表，例如在 `for` 循环的初始化、条件和迭代部分，或者在函数调用中分隔参数。逗号运算符的结合性是左结合，这意味着表达式会从左到右计算，带逗号的表达式整体的值就是最后那个被逗号分隔开的表达式的值，比如如果你写

```c
int a = 2, 4;
```

结果 `a` 的值就是 4

## 注释

C 语言有两种注释方式：

```c
// 单行注释
```

以 // 开始的单行注释，这种注释可以单独占一行。

```c
/* 单行注释 */
/* 
 多行注释
 多行注释
 多行注释
 */
```

/* */ 这种格式的注释可以单行或多行。

您不能在注释内嵌套注释，注释也不能出现在字符串或字符值中。

## 标识符

标识符是用来标识变量、函数，或任何其他用户自定义项目的名称。一个标识符以字母 A-Z 或 a-z 或下划线 _ 开始，后跟零个或多个字母、下划线和数字（0-9）。

C 标识符内不允许出现标点字符，比如 `@`、`$` 和 `%`。C 是**区分大小写**的编程语言。因此，在 C 中，_Manpower_ 和 _manpower_ 是两个不同的标识符。下面列出几个有效的标识符：

```
mohd       zara    abc   move_name  a_123
myname50   _temp   j     a23b9      retVal
```

## 关键字/保留字

C 语言中有一些特别的词，它们在C语言中已经被赋予了特定的意义，所以程序员**不能用这些词来作为常量名、变量名或其他标识符名称** ，这些词就是 **保留字/关键字**，

下表列出了 C 中的保留字。你需要大致了解它们，不过不必特地去背，往后会你会熟练地使用许多包含这些关键字的语句，而且绝大多数文本编辑器都支持编程语言语法高亮，你可以轻松地判断出自己起的标识符是否为保留字。

| 关键字 | 说明 |
|--|--|
| auto | 声明自动变量 |
| break | 跳出当前循环 |
| case | 开关语句分支 |
| char | 声明字符型变量或函数返回值类型 |
| const | 定义常量，如果一个变量被 const 修饰，那么它的值就不能再被改变 |
| continue | 结束当前循环，开始下一轮循环 |
| default | 开关语句中的"其它"分支 |
| do | 循环语句的循环体 |
| double | 声明双精度浮点型变量或函数返回值类型 |
| else | 条件语句否定分支（与 if 连用） |
| enum | 声明枚举类型 |
| extern | 声明变量或函数是在其它文件或本文件的其他位置定义 |
| float | 声明浮点型变量或函数返回值类型 |
| for | 一种循环语句 |
| goto | 无条件跳转语句 |
| if | 条件语句 |
| int | 声明整型变量或函数 |
| long | 声明长整型变量或函数返回值类型 |
| register | 声明寄存器变量 |
| return | 子程序返回语句（可以带参数，也可不带参数） |
| short | 声明短整型变量或函数 |
| signed | 声明有符号类型变量或函数 |
| sizeof | 计算数据类型或变量长度（即所占字节数） |
| static | 声明静态变量 |
| struct | 声明结构体类型 |
| switch | 用于开关语句 |
| typedef | 用以给数据类型取别名 |
| unsigned | 声明无符号类型变量或函数 |
| union | 声明共用体类型 |
| void | 声明函数无返回值或无参数，声明无类型指针 |
| volatile | 说明变量在程序执行中可被隐含地改变 |
| while | 循环语句的循环条件 |

### C99 新增关键字

- `_Bool`
- `_Complex`
- `_Imaginary`
- `inline`
- `restrict`

### C11 新增关键字

- `_Alignas`
- `_Alignof`
- `_Atomic`
- `_Generic`
- `_Noreturn`
- `_Static_assert`
- `_Thread_local`

事实上，在某些情况下，人们可能会区分“关键字”和“保留字”，但这通常是指：

-   **关键字**：指那些在C语言标准中明确定义的保留字，它们在所有C语言的实现中都必须被保留。
-   **扩展关键字/保留字**：某些编译器可能支持超出标准C语言的额外特性，这些特性可能引入了额外的关键字/保留字，这些可以被视为特定编译器的“扩展关键字/保留字”。

但在日常使用中，这两个词通常是可以互换的，它们都指的是那些不能用作标识符的预定义词汇。


# C 语言基础

## 类型 

在 C 语言中，数据类型指的是用于声明不同类型的变量或函数的一个广泛的系统。变量的类型决定了变量存储占用的空间，以及如何解释存储的位模式。

C 中的类型可分为以下几种：

基本数据类型  
:	它们是算术类型，包括整型（int）、字符型（char）、浮点型（float）和双精度浮点型（double）。

枚举类型
:	它们也是算术类型，被用来定义在程序中只能赋予其一定的离散整数值的变量。

void 类型
:	类型说明符 _void_ 表示没有值的数据类型，通常用于函数返回值。

派生类型
:	包括数组类型、指针类型和结构体类型。

数组类型和结构类型统称为 *聚合类型* 。函数的类型指的是函数返回值的类型。

类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中。下表列举了 C 中的基本数据类型及其变量所占的内存：

| 类型     | 描述                                                                                                                                        |
| ------ | ----------------------------------------------------------------------------------------------------------------------------------------- |
| char   | 通常是一个字节（八位）, 这是一个整数类型。                                                                                                                    |
| short  | 整数，两个字节。                                                                                                                                  |
| int    | 整型，4 个字节，取值范围 -2147483648 到 2147483647。                                                                                                   |
| float  | 单精度浮点值。单精度是这样的格式，1位符号，8位指数，23位小数（共4个字节）。![](https://www.runoob.com/wp-content/uploads/2014/09/v2-749cc641eb4d5dafd085e8c23f8826aa_hd.png) |
| double | 双精度浮点值。双精度是1位符号，11位指数，52位小数（共8个字节）。![](https://www.runoob.com/wp-content/uploads/2014/09/v2-48240f0e1e0dd33ec89100cbe2d30707_hd.png)      |
| void   | 表示类型的缺失。                                                                                                                                  |

## 变量

变量其实只不过是程序可操作的存储区的名称。C 中每个变量都有特定的类型（就是上文提到的那些）。运算符可应用于变量上。

变量的名称可以由字母、数字和下划线字符组成。它必须以字母或下划线开头。大写字母和小写字母是不同的，因为 **C 是大小写敏感的** 。

C 语言也允许定义各种其他类型的变量，比如枚举、指针、数组、结构、共用体等等，这将会在后续的内容中进行讲解，本章节我们先讲解基本变量类型。

### 定义变量

变量定义就是告诉编译器在何处创建变量的存储，以及如何创建变量的存储。变量定义指定一个数据类型，并包含了该类型的一个或多个变量的列表，如下所示：

```c
type variable_list;
```

**type** 表示变量的数据类型，可以是整型、浮点型、字符型、指针等，也可以是用户自定义的对象。

**variable_list** 可以由一个或多个变量的名称组成，多个变量之间用逗号 `,` 分隔，变量由字母、数字和下划线组成，且以字母或下划线开头。

下面列出几个有效的声明：

定义整型变量：

```c
int age;
```

以上代码中，`age` 被定义为一个整型变量。

定义指针变量：

```c
int *ptr;
```

以上代码中，`ptr` 被定义为一个整型指针变量。

定义多个变量：

```c
int i, j, k;
```

`int i, j, k` 声明并定义了变量 `i、j 和 k`，这指示编译器创建类型为 int 的名为 `i、j、k` 的变量。

在 C 语言中，变量的初始化是在定义变量的同时为其赋予一个初始值。变量的初始化可以在定义时进行，也可以在后续的代码中进行。

初始化器由一个等号，后跟一个常量表达式组成，如下所示：

```c
type variable_name = value;
```

其中，**type** 表示变量的数据类型，**variable_name** 是变量的名称，**value** 是变量的初始值。

下面列举几个实例：

```c
int x = 10;         // 整型变量 x 初始化为 10
float pi = 3.14;    // 浮点型变量 pi 初始化为 3.14
char ch = 'A';      // 字符型变量 ch 初始化为字符 'A'
int d = 3, f = 5;           // 定义并初始化 d 和 f
byte z = 22;                // 定义并初始化 z

// 声明外部变量
extern int d;
extern int f;
```

在变量定义后的代码中，可以使用赋值运算符 = 为变量赋予一个新的值。

```c
type variable_name;    // 变量定义
variable_name = new_value;    // 变量初始化
```

实例如下：

```c
int x;          // 整型变量x定义
x = 20;         // 变量x初始化为20
float pi;       // 浮点型变量pi定义
pi = 3.14159;   // 变量pi初始化为3.14159
char ch;        // 字符型变量ch定义
ch = 'B';       // 变量ch初始化为字符'B'
```

需要注意的是，**变量在使用之前应该被初始化。未初始化的变量的值是未定义的，可能包含任意的垃圾值。因此，为了避免不确定的行为和错误，建议在使用变量之前进行初始化。**

在 C 语言中，如果变量没有显式初始化，那么它的默认值将取决于该变量的类型和其所在的作用域。

对于全局变量和静态变量（在函数内部定义的静态变量和在函数外部定义的全局变量），它们的默认初始值为零。

以下是不同类型的变量在没有显式初始化时的默认值：

-   整型变量（int、short、long等）：默认值为0。
-   浮点型变量（float、double等）：默认值为0.0。
-   字符型变量（char）：默认值为'\0'，即空字符。
-   指针变量：默认值为NULL，表示指针不指向任何有效的内存地址。
-   数组、结构体、联合等复合类型的变量：它们的元素或成员将按照相应的规则进行默认初始化，这可能包括对元素递归应用默认规则。

需要注意的是，局部变量（在函数内部定义的非静态变量）不会自动初始化为默认值，它们的初始值是未定义的（包含垃圾值）。因此，在使用局部变量之前，应该显式地为其赋予一个初始值。

总结起来，C 语言中变量的默认值取决于其类型和作用域。全局变量和静态变量的默认值为 0，字符型变量的默认值为 \0，指针变量的默认值为 NULL，而局部变量没有默认值，其初始值是未定义的。

### C 中的变量声明

变量声明向编译器保证变量以指定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。

变量的声明有两种情况：

1. 一种是需要建立存储空间的。例如：int a 在声明的时候就已经建立了存储空间。
2. 另一种是不需要建立存储空间的，通过使用extern关键字声明变量名而不定义它。 例如`extern int a` 中变量 a 可以在别的文件中定义的。

除非有 extern 关键字，否则都是变量的定义。

```c
extern int i; //声明，不是定义，它告诉编译器“这儿有个i我们可以拿来用”。
int i; //声明，也是定义，它告诉编译器“我们要新建一个i”。
```

### 赋值

你可以在定义变量的同时时为变量赋值：

```c
int n = 10;
int a = 2, b = 3; // 给多个变量赋值
```

如果要给两个变量赋相同的值，你可以这样：

```c
int a = 2, b = 2;
```

或者

```c
int a, b;
a = b = 2;
```

**但绝不能是**

```c
int a = b = 2;
```

因为 `=` 单独在语句中作为赋值符号时，其 *结合性* 是从右至左的，也就是说，连续的赋值相当于这样：

```c
a = (b = 2);
```

那么 `int a = b = 2` 这样的句子也就相当于 `int a = (b = 2)` ，这时 `b` 还没有被定义，因此会出现错误。

换言之，

```c
int b;
int a = b = 1;
```

这么写就是可行的（不过明显不如将 `a` 与 `b` 全部一起声明后再赋值）。

### 左值和右值

C 中有两种类型的表达式：

**左值（lvalue）** 
: 左值（lvalue）是指那些在内存中有持久存储位置的表达式结果。

**右值（rvalue）** 
: 右值是指那些在内存中没有持久存储位置的表达式结果，它们通常是临时的值，例如字面量、函数调用的结果或者算术运算的结果。。

它们有着很多的区别：

首先，**左值可以出现在赋值号的左边或右边，而右值只能出现在赋值语句的右侧。** 变量是左值，因此可以出现在赋值号的左边。数值型的字面值是右值，因此不能被赋值，不能出现在赋值号的左边。下面是一个有效的语句：

```c
int g = 20;
```

但是下面这个就不是一个有效的语句，会生成编译时错误：

```c
10 = 20;
```

右值自然是不可用赋值语句修改的，但其实左值也不尽然。左值可以分为可修改的和不可修改的两大类，可修改的左值通常是变量，包括普通的变量、数组元素、结构体成员等；而 **不可修改的左值包括数组名、函数名、字符串字面量、以及常量左值。** 你可能现在还不认识它们，总之继续学下去你就知道了。

此外，**左值有明确的内存地址，可以使用取地址运算符 `&` 获取其地址，如果它们是指针类型的话也可以被解引用；右值没有持久的内存地址，它们通常是寄存器中的值或者是临时对象，故也不能被取地址或解引用。** 这也是不可修改的左值跟右值的一个重要区别。

啊，你问什么是 *取地址* 和 *解引用* ？没关系，等学到指针时你就明白了，届时我也会再次提到这里左右值的性质。

## 类型转换

### 强制类型转换

**强制类型转换** 是把变量从一种类型转换为另一种数据类型。例如，如果您想存储一个 long 类型的值到一个简单的整型中，您需要把 long 类型强制转换为 int 类型。您可以使用 **强制类型转换运算符** 来把值显式地从一种类型转换为另一种类型，如下所示：

```c
(type_name) expression
```

请看下面的实例，使用强制类型转换运算符把一个整数变量除以另一个整数变量，得到一个浮点数：

```c
#include <stdio.h> 

int main() 
{ 
	int sum = 17, count = 5; 
	double mean; 
	mean = (double) sum / count; 
	printf("Value of mean : %f\n", mean ); 
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
Value of mean : 3.400000
```

这里要注意的是强制类型转换运算符的优先级大于除法，因此 `sum` 的值首先被转换为 double 型，然后除以 `count`，得到一个类型为 double 的值。

类型转换可以是隐式的，由编译器自动执行（自动类型转换），也可以是显式的，通过使用**强制类型转换运算符**来指定。**无论如何，在编程时，有需要类型转换的时候都用上强制类型转换运算符，是一种良好的编程习惯。**

### 整数提升

整数提升是指把小于 int 或 unsigned int 的整数类型转换为 int 或 unsigned int 的过程。请看下面的实例，在 int 中添加一个字符：

```c
#include <stdio.h> 

int main() 
{ 
	int i = 17; 
	char c = 'c'; /* ascii 值是 99 */ 
	int sum; 
	sum = i + c; 
	printf("Value of sum : %d\n", sum ); 
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
Value of sum : 116
```

在这里，`sum` 的值为 116，因为编译器进行了整数提升，在执行实际加法运算时，把 'c' 的值转换为对应的 ascii 值。

### 常用的算术转换（自动类型转换）

**常用的算术转换** 是隐式地把值转换为相同的类型。编译器首先执行**整数提升**，如果操作数类型不同，则它们会被转换为下列层次中出现的最高层次的类型：

![Usual Arithmetic Conversion](https://www.runoob.com/wp-content/uploads/2014/08/usual_arithmetic_conversion.png)

常用的算术转换不适用于赋值运算符、逻辑运算符 && 和 ||。让我们看看下面的实例来理解这个概念：

```c
#include <stdio.h> 

int main() 
{ 
	int i = 17; 
	char c = 'c'; /* ascii 值是 99 */ 
	float sum; sum = i + c; 
	printf("Value of sum : %f\n", sum ); 
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
Value of sum : 116.000000
```

在这里，`c` 首先被转换为整数，但是由于最后的值是 float 型的，所以会应用常用的算术转换，编译器会把 `i` 和 `c` 转换为浮点型，并把它们相加得到一个浮点数。

## 作用域

任何一种编程中，作用域是程序中定义的变量所存在的区域，超过该区域变量就不能被访问。C 语言中有三个地方可以声明变量：

1.  在函数或块内部的 **局部变量**
2.  在所有函数外部的 **全局变量**
3.  在 **形式参数** 的函数参数定义中

让我们来看看什么是局部变量、全局变量和形式参数。

### 局部变量

在某个函数或块的内部声明的变量称为局部变量。它们只能被该函数或该代码块内部的语句使用。局部变量在函数外部是不可知的。下面是使用局部变量的实例。在这里，所有的变量 a、b 和 c 是 main() 函数的局部变量。

```c
#include <stdio.h> 
int main () 
{ 
	/* 局部变量声明 */ 
	int a, b; 
	int c; 
	
	/* 实际初始化 */ 
	a = 10; 
	b = 20; 
	c = a + b; 
	
	printf ("value of a = %d, b = %d and c = %d\n", a, b, c); 
	return 0; 
}
```

### 全局变量

全局变量是定义在函数外部，通常是在程序的顶部。全局变量在整个程序生命周期内都是有效的，在任意的函数内部能访问全局变量。

全局变量可以被任何函数访问。也就是说，全局变量在声明后整个程序中都是可用的。下面是使用全局变量和局部变量的实例：

```c
#include <stdio.h> 

/* 全局变量声明 */ 
int g; 

int main () 
{
	/* 局部变量声明 */ 
	int a, b; 
	
	/* 实际初始化 */ 
	a = 10; 
	b = 20; 
	g = a + b; 
	printf ("value of a = %d, b = %d and g = %d\n", a, b, g); 
	return 0; 
}
```

在程序中，局部变量和全局变量的名称可以相同，但是在函数内，如果两个名字相同，会使用局部变量值，全局变量不会被使用：

```c
#include <stdio.h> 

/* 全局变量声明 */ 
int g = 20; 

int main () 
{ 
	/* 局部变量声明 */ 
	int g = 10; 
	printf ("value of g = %d\n", g); 
	return 0; 
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
value of g = 10
```

### 形式参数

函数的参数，形式参数，被当作该函数内的局部变量，如果与全局变量同名它们会优先使用：

```c
#include <stdio.h> 

/* 全局变量声明 */ 
int a = 20; 

int main () 
{ 
	/* 在主函数中的局部变量声明 */ 
	int a = 10; 
	int b = 20; 
	int c = 0; 
	int sum(int, int); // 嗯，函数在这里声明也是可以的。
	printf ("value of a in main() = %d\n", a); 
	c = sum( a, b); 
	printf ("value of c in main() = %d\n", c); 
	return 0; 
} 

/* 添加两个整数的函数 */ 
int sum(int a, int b) 
{ 
	printf ("value of a in sum() = %d\n", a); 
	printf ("value of b in sum() = %d\n", b); 
	return a + b; 
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
value of a in main() = 10
value of a in sum() = 10
value of b in sum() = 20
value of c in main() = 30
```

> **全局变量与局部变量在内存中的区别**：
> 
> -   全局变量保存在内存的全局存储区中，占用静态的存储单元；
> -   局部变量保存在栈中，只有在所在函数被调用时才动态地为变量分配存储单元。

### 初始化局部变量和全局变量

当局部变量被定义时，系统不会对其初始化，您必须自行对其初始化。**定义全局变量时，系统会自动对其初始化** ，如下所示：

| 数据类型 | 初始化默认值 |
|--|--|
| int | 0 |
| char | '\0' |
| float | 0 |
| double | 0 |
| pointer | NULL |

**正确地初始化变量是一个良好的编程习惯，否则有时候程序可能会产生意想不到的结果，因为未初始化的变量会导致一些在内存位置中已经可用的垃圾值。**

## 字面量

**字面量（Literal）** 是编程语言中表示固定值的表示法，它们是源代码中直接给出的值，而不是通过计算或变量引用得到的，比如具体的数值，像 `1010`，`3.14` 之类的。字面量通常用于初始化变量、数组、常量等，或者在表达式中直接使用。


### 整数字面量

整数字面量可以是十进制、八进制或十六进制的常量。前缀指定基数：`0x` 或 `0X` 表示十六进制，`0` 表示八进制，不带前缀则默认表示十进制。

整数字面量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。

下面列举几个整数字面量的实例：

```c
212         /* 合法的 */
215u        /* 合法的 */
0xFeeL      /* 合法的：这里指十六进制长整数FEE */
078         /* 非法的：8 不是八进制的数字 */
032UU       /* 非法的：不能重复后缀 */
```

以下是各种类型的整数字面量的实例：

```c
85         /* 十进制 */
0213       /* 八进制 */
0x4b       /* 十六进制 */
30         /* 整数 */
30u        /* 无符号整数 */
30l        /* 长整数 */
30ul       /* 无符号长整数 */
```

整数字面量可以带有一个后缀表示数据类型，例如：

```c
int myInt = 10;  
long myLong = 100000L;  
unsigned int myUnsignedInt = 10U; 
``` 

### 浮点字面量

浮点字面量由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。

当使用小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。当使用指数形式表示时， 必须包含小数点、指数，或同时包含两者。带符号的指数是用 e 或 E 引入的。

下面列举几个浮点字面量的实例：

```c
3.14159       /* 合法的 */
314159E-5L    /* 合法的 */
510E          /* 非法的：不完整的指数 */
210f          /* 非法的：没有小数或指数 */
486e5.1		  /* 非法的：e 的后面都不能是小数 */
.e55          /* 非法的：缺少整数或分数 */
```

浮点数字面量默认是 `double` 类型，不过可以借助后缀来指定其他类型：

- 没有后缀时，像 `3.14` 这样的浮点数常量默认是 `double` 类型。
- 后缀为 `f` 或者 `F` 时，如 `3.14f` 代表 `float` 类型。
- 后缀为 `l` 或者 `L` 时，例如 `3.14l` 表示 `long double` 类型。

```c
float myFloat = 3.14f;  
double myDouble = 3.14159;  
```

### 字符字面量

字符字面量是括在单引号中，例如，`'x'` 可以存储在 **char** 类型的简单变量中。

字符字面量可以是一个普通的字符（例如 `'x'`）、一个转义序列（例如 `'\t'`），或一个通用的字符（例如 `'\u02C0'`）。

在 C 中，有一些特定的字符，当它们前面有反斜杠时，它们就具有特殊的含义，被用来表示如换行符（`\n`）或制表符（`\t`）等。下表列出了一些这样的转义序列码：

| 转义序列     | 含义                   |
| -------- | -------------------- |
| \\\      | \ 字符                 |
| \\'      | ' 字符                 |
| \\"      | " 字符                 |
| \\?      | ? 字符                 |
| \\a      | 警报铃声（输出这个的话电脑应该会响一下） |
| \\b      | 退格键                  |
| \\f      | 换页符                  |
| \\n      | 换行符                  |
| \\r      | 回车（回到开头）             |
| \\t      | 水平制表符                |
| \\v      | 垂直制表符                |
| \\ooo    | 一到三位的八进制数            |
| \\xhh... | 一个或多个数字的十六进制数        |


字符字面量的 ASCII 值可以通过强制类型转换转换为整数值。

```c
char myChar = 'a';  
int myAsciiValue = (int) myChar; // 将 myChar 转换为 ASCII 值 97  
```

### 字符串字面量

c语言中，一个字符串实质上就是一个以 `\0` 做结尾的 char 数组，你可以将字符串常量就看作是一种对 char 数组字面量的简化：

```c
char myString[] = "hello EBAOBAO";

// 相当于……

char myString[] = {
	'h', 'e', 'l' ,'l', 'o', ' ', 
	'E', 'B', 'A', 'O', 'B', 'A', 
	'O', '\0'
};
```

什么，你说你还不知道数组是什么？没关系，总之先记住你可以像 `char str[] = "hello"` 或者 `char str[999（数字要大于字符串长度）] = "hello"` 这样来声明一个字符串变量就行了。

不过事实上，字符串字面量并不完全等于字符数组字面量，因为 **字符串字面量是个左值**，虽然它不可被修改，不过它确实是个左值，因为它可以被取地址：

```c
#include <stdio.h>

int main() {
	printf("%x", &"hello world");
	return 0;
}
```

像这样就是没问题的。

字符串字面量或常量是括在双引号 " " 中的。一个字符串包含类似于字符常量的字符：普通的字符、转义序列和通用的字符。

可以使用反斜杠对长字符串进行拆分，反斜杠后的换行符会被C忽略，所以可以拆分字符串，但是下一行的空格会被计算在内，所以这样拆分就要取消第一行后面那几行的缩进：

```c
#include <stdio.h>

int main() {
	char str[] = "hello, \
ebaobao";
	printf(str);
	return 0;
}
```

下面的实例显示了一些字符串字面量。下面这三种形式所显示的字符串是相同的。

```c
"hello, dear"
"hello, \
dear"
"hello, " "d" "ear"
```

字符串字面量在内存中以 null 终止符 `\0` 结尾。例如：

```c
char myString[] = "Hello, world!"; //系统对字符串常量自动加一个 '\0'
```

关于字符串字面量还有一些更为深入的内容，之后在 *字符串* 相关内容中会详细讨论。

## 常量

**常量** 是固定值的一个变量，在程序执行期间不会改变。

常量可以是任何的基本数据类型，比如整数常量、浮点常量、字符常量，或字符串字面值，也有枚举常量。

常量就像是常规的变量，只不过常量的值在定义后不能进行修改。

常量可以直接在代码中使用，也可以通过定义常量来使用。

**注意，常量是一种不可修改的左值，而字面量则是右值！**

### 定义常量

在 C 中，有两种简单的定义常量的方式：

1.  使用 `#define` 预处理器： `#define` 可以在程序中定义一个常量，它在编译时会被替换为其对应的值。
2.  使用 `cons` 关键字：const 关键字用于声明一个只读变量，即该变量的值不能在程序运行时修改。

#### #define 预处理器

下面是使用 `#define` 预处理器定义常量的形式：

```c
#define 常量名 常量值
```

（**注意末尾没有分号！！**）

下面的代码定义了一个名为 PI 的常量：

```c
#define PI 3.14159
```

在程序中使用该常量时，编译器会将所有的 `PI` 替换为 3.14159。

具体请看下面的实例：

```c
#include <stdio.h> 
#define LENGTH 10 
#define WIDTH 5 
#define NEWLINE '\n' 
int main() { 
int area; 
	area = LENGTH * WIDTH; 
	printf("value of area : %d", area); 
	printf("%c", NEWLINE); 
	return 0; 
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
value of area : 50
```

#### const 关键字

您可以使用 `const` 前缀声明指定类型的常量，如下所示：

```c
const 数据类型 常量名 = 常量值;
```

下面的代码定义了一个名为MAX_VALUE的常量：

```c
const int MAX_VALUE = 100;
```

在程序中使用该常量时，其值将始终为100，并且不能被修改。

![](https://www.runoob.com/wp-content/uploads/2014/09/c-const-2021-01-15.png)

const 声明常量要在一个语句内完成：

![](https://www.runoob.com/wp-content/uploads/2014/09/c-const-2021-01-15-2.png)

具体请看下面的实例：

```c
#include <stdio.h> 
int main() { 
	const int LENGTH = 10; 
	const int WIDTH = 5; 
	const char NEWLINE = '\n'; 
	int area; area = LENGTH * WIDTH; 
	printf("value of area : %d", area); 
	printf("%c", NEWLINE); 
	return 0; 
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
value of area : 50
```

**请注意，把常量定义为大写字母形式，是一个很好的编程习惯。**

#### #define 与 const 区别

`#define` 与 `const` 这两种方式都可以用来定义常量，选择哪种方式取决于具体的需求和编程习惯。**通常情况下，建议使用 const 关键字来定义常量** ，因为它具有类型检查和作用域的优势，而 #define 仅进行简单的文本替换，可能会导致一些意外的问题。

#define 预处理指令和 const 关键字在定义常量时有一些区别：

-   替换机制：`#define` 是进行简单的文本替换，而 `const` 是声明一个具有类型的常量。`#define` 定义的常量在编译时会被直接替换为其对应的值，而 `const` 定义的常量在程序运行时会分配内存，并且具有类型信息。
    
-   类型检查：`#define` 不进行类型检查，因为它只是进行简单的文本替换。而 `const` 定义的常量具有类型信息，编译器可以对其进行类型检查。这可以帮助捕获一些潜在的类型错误。
    
-   作用域：`#define` 定义的常量没有作用域限制，它在定义之后的整个代码中都有效。而 `const` 定义的常量具有块级作用域，只在其定义所在的作用域内有效。
    
-   调试和符号表：使用 `#define` 定义的常量在符号表中不会有相应的条目，因为它只是进行文本替换。而使用 `const` 定义的常量会在符号表中有相应的条目，有助于调试和可读性。



## 运算符

运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。C 语言内置了丰富的运算符，并提供了以下类型的运算符：

-   算术运算符
-   关系运算符
-   逻辑运算符
-   位运算符
-   赋值运算符
-   杂项运算符

本章将逐一介绍算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符和其他运算符。

### 算术运算符

下表显示了 C 语言支持的所有算术运算符。假设变量 **A** 的值为 10，变量 **B** 的值为 20，则：

| 运算符 | 描述 | 实例 |
|--|--|--|
| + | 把两个操作数相加 | A + B 将得到 30 |
| - | 从第一个操作数中减去第二个操作数 | A - B 将得到 -10 |
| * | 把两个操作数相乘 | A * B 将得到 200 |
| / | 分子除以分母 | B / A 将得到 2 |
| % | 取模运算符，整除后的余数 | B % A 将得到 0 |
| ++ | 自增运算符，整数值增加 1 | A++ 将得到 11 |
| -- | 自减运算符，整数值减少 1 | A-- 将得到 9 |

#### 自增自减

他们的运算对象可以是int类型变量，float类型变量，double类型变量，char类型变量。

除了在变量后面的 `++` 与 `--` 符是先赋值后运算的外，在变量前的 `++` 与 `--` 符以及 `=`、`+=`、`-=` 等赋值符号都是先运算后赋值的，也就是说

```c
y = i++;
```

这里的 `y` 是 `i` 原来的值，`i++` 作为一条语句而言能使 `i` 自增，但作为一个赋给其他变量的值而言 `i++` 会返回 `i` 自增前的值。

而

```c
a = ++i;
b = (i = 7);
c = (i += 6);
``` 
这些语句就返回的都是 `i` 在运算后的值了。

有趣的是，

```c
i = i++;
```

执行完这样的语句后，`i` 的值依旧是其自增前的值，你可以这么理解它：

```c
int temp = i; // 先赋值……
i += 1; // 后运算，正如上文所说，不是吗？
i = temp;

// 简单地说……
// int temp = i++;
// i = temp;
```

相应地，`i = ++i` 也就像是这样：

```c
i += 1; // 先运算
int temp = i // 后赋值
i = temp;

// 同理……
// int temp = ++i;
// i = temp;
```

除了上述差别外，`p++` 与 `++p` 还有个差别，那就是 **`p++` 返回一个右值，而 `++p` 返回一个左值！** 而它们倒都是只能作用于一个左值，这就给我们带来一些有趣的现象，比如 `++++p` 是合法的，但 `p++++`就不合法了（不过谁会这么写呢）。

但是在有编译器中（比如我的 gcc 编译器，g++ 就没问题），`++p` 并不是返回左值的，这点请注意。

#### 取余

取余，也就是求余数，使用的运算符是 %。C 语言中的取余运算只能针对整数，也就是说，% 的两边都必须是整数，不能出现小数，否则编译器会报错。

另外，余数可以是正数也可以是负数，由 % 左边的整数决定：

-   如果 % 左边是正数，那么余数也是正数；
-   如果 % 左边是负数，那么余数也是负数；

请看下面的例子：

```c
#include <stdio.h>

int main()
{
    printf( "100%%12=%d \n100%%-12=%d \n-100%%12=%d \n-100%%-12=%d \n", 100%12, 100%-12, -100%12, -100%-12 );
    return 0;
}
```
运行结果：

```
100%12=4
100%-12=4
-100%12=-4
-100%-12=-4
```

### 关系运算符

下表显示了 C 语言支持的所有关系运算符。假设变量 `A` 的值为 10，变量 `B` 的值为 20，则：

| 运算符 | 描述 | 实例 |
|--|--|--|
| == | 检查两个操作数的值是否相等，如果相等则条件为真。 | (A == B) 为假。 |
| != | 检查两个操作数的值是否相等，如果不相等则条件为真。 | (A != B) 为真。 |
| > | 检查左操作数的值是否大于右操作数的值，如果是则条件为真。 | (A > B) 为假。 |
| < | 检查左操作数的值是否小于右操作数的值，如果是则条件为真。 | (A < B) 为真。 |
| >= | 检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。 | (A >= B) 为假。 |
| <= | 检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。 | (A <= B) 为真。 |

### 逻辑运算符

下表显示了 C 语言支持的所有关系逻辑运算符。假设变量 `A` 的值为 1，变量 `B` 的值为 0，则：

| 运算符 | 描述 | 实例 |
|--|--|--|
| && | 称为逻辑与运算符。如果两个操作数都非零，则条件为真。 | (A && B) 为假。 |
| \|\| | 称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。 | (A \|\| B) 为真。 |
| ! | 称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。 | !(A && B) 为真。 |

**注意 C 语言没有布尔类型的值！C 语言把任何非零和非空的值假定为 true，把零或 null 假定为 false**。

事实上，C 语言中的逻辑与与逻辑或是短路与与短路或，就比如说，如果 `A && B` 中 `A` 为假的话，整个表达式直接返回假，程序不会去注意 `B`，毕竟不管 `B` 怎么样结果已经确定了，同理 `A || B` 中要是 `A` 为真也就直接返回真。这里的“短路”特性一方面可以提高程序执行效率，**另一方面还能控制语句执行！** 比如要是 `A && b++` 中 `A` 为假的话，`b` 就不会自增了；要是 `A && 1 / 0` 中 `A` 为假的话，程序就不会报错！

### 位运算符

位运算符作用于位，并逐位执行操作。&、 | 和 ^ 的真值表如下所示：

| p | q | p & q | p \| q | p ^ q |
|--|--|--|--|--|
| 0 | 0 | 0 | 0 | 0 |
| 0 | 1 | 0 | 1 | 1 |
| 1 | 1 | 1 | 1 | 0 |
| 1 | 0 | 0 | 1 | 1 |

假设如果 A = 60，且 B = 13，现在以二进制格式表示，它们如下所示：

```
A = 0011 1100

B = 0000 1101

-----------------

A&B = 0000 1100

A|B = 0011 1101

A^B = 0011 0001

~A = 1100 0011
```

下表显示了 C 语言支持的位运算符。假设变量 `A` 的值为 60，变量 `B` 的值为 13，则：

| 运算符 | 描述 | 实例 |
|--|--|--|
| & | 对两个操作数的每一位执行逻辑与操作，如果两个相应的位都为 1，则结果为 1，否则为 0。 | (A & B) 将得到 12，即为 0000 1100 |
| \| | 对两个操作数的每一位执行逻辑或操作，如果两个相应的位都为 0，则结果为 0，否则为 1。 | (A \| B) 将得到 61，即为 0011 1101 |
| ^ | 对两个操作数的每一位执行逻辑异或操作，如果两个相应的位值相同，则结果为 0，否则为 1。 | (A ^ B) 将得到 49，即为 0011 0001 |
| ~ | 对操作数的每一位执行逻辑取反操作，即将每一位的 0 变为 1，1 变为 0。 | (~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。 |
| << | 将操作数的所有位向左移动指定的位数。左移 n 位相当于乘以 2 的 n 次方（左边的二进制位丢弃，右边补0）。 | A << 2 将得到 240，即为 1111 0000 |
| >> | 将操作数的所有位向右移动指定的位数。右移n位相当于除以 2 的 n 次方（用符号位补左边，正数补0，负数补1）。 | A >> 2 将得到 15，即为 0000 1111 |

事实上，按位与或在一定程度上可以用以代替逻辑与或，

### 赋值运算符

下表列出了 C 语言支持的赋值运算符：


| 运算符 | 描述 | 实例 |
|--|--|--|
| = | 简单的赋值运算符，把右边操作数的值赋给左边操作数 | C = A + B 将把 A + B 的值赋给 C |
| += | 加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数 | C += A 相当于 C = C + A |
| -= | 减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数 | C -= A 相当于 C = C - A |
| *= | 乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数 | C *= A 相当于 C = C * A |
| /= | 除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数 | C /= A 相当于 C = C / A |
| %= | 求模且赋值运算符，求两个操作数的模赋值给左边操作数 | C %= A 相当于 C = C % A |
| <<= | 左移且赋值运算符 | C <<= 2 等同于 C = C << 2 |
| >>= | 右移且赋值运算符 | C >>= 2 等同于 C = C >> 2 |
| &= | 按位与且赋值运算符 | C &= 2 等同于 C = C & 2 |
| ^= | 按位异或且赋值运算符 | C ^= 2 等同于 C = C ^ 2 |
| \|= | 按位或且赋值运算符 | C \|= 2 等同于 C = C \| 2 |

### 杂项运算符 ↦ sizeof & 三元

下表列出了 C 语言支持的其他一些重要的运算符，包括 **sizeof** 和 **? :**。


| 运算符 | 描述 | 实例 |
|--|--|--|
| sizeof() | 返回变量的大小（内存中所占字节数）。 | `sizeof(a)` 将返回 4，其中 a 是整数。 |
| & | 返回变量的地址。 | `&a;` 将给出变量的实际地址。 |
| * | 指向一个变量。 | `*a;` 将指向一个变量。 |
| ? : | 条件表达式 | 如果条件为真 ? 则值为 X : 否则值为 Y |

### 运算符优先级与结合性

运算符的* 优先级* 确定表达式中项的组合，而 *结合性* 指的是当表达式中包含多个相同优先级的运算符时，它们是如何组合的，**"左结合"（Left Associative）** 意味着从左到右计算，**"右结合"（Right Associative）** 意味着从右到左计算，**"非结合"（Non-Associative）** 意味着不能在没有括号的情况下组合，它们会影响到一个表达式如何计算。某些运算符比其他运算符有更高的优先级，例如，乘除运算符具有比加减运算符更高的优先级，就是说在一个表达式中，我们先算乘除后算加减。

例如 `x = 7 + 3 * 2`，在这里，`x` 被赋值为 13，而不是 20，因为运算符 `*` 具有比 `+` 更高的优先级，所以首先计算乘法 `3*2`，然后再加上 7。

以下是 C 语言中所有运算符的优先级和结合性。数字越小，优先级越高。

1. 圆括号 `(x)`
2. 后缀运算符
	   - `x++`（后增）
	   - `x--`（后减）
	   - `x[y]`（数组下标）
	   - `x(y)`（函数调用）
	   - `x.y`（成员访问）
	   - `x->y`（指向成员访问）
	   - **结合性**：非结合

3. 单目运算符
	   - `++x`（前增）
	   - `--x`（前减）
	   - `+x`（正号）
	   - `-x`（负号）
	   - `!x`（逻辑非）
	   - `~x`（按位取反）
	   - `*x`（指针）
	   - `&x`（地址）
	   - `sizeof`（大小）
	   - **结合性**：**右结合**

4. 乘法和除法（优先级相同）
	   - `*`（乘）
	   - `/`（除）
	   - `%`（模）
	   - **结合性**：左结合

5. 加法和减法（优先级相同）
	   - `+`（加）
	   - `-`（减）
	   - **结合性**：左结合

6. 位移运算符（优先级相同）
	   - `<<`（左移）
	   - `>>`（右移）
	   - **结合性**：左结合

8. 关系运算符（优先级相同）
	   - `<`（小于）
	   - `>`（大于）
	   - `<=`（小于等于）
	   - `>=`（大于等于）
	   - **结合性**：左结合

9. 相等性运算符（优先级相同）
	   - `==`（等于）
	   - `!=`（不等于）
	   - **结合性**：左结合

10. 位与运算符
	   - `&`（位与）
	   - **结合性**：左结合

11. 位异或运算符
	   - `^`（位异或）
	   - **结合性**：左结合

12. 位或运算符
    - `|`（位或）
    - **结合性**：左结合

13. 逻辑与运算符
    - `&&`（逻辑与）
    - **结合性**：左结合

14. 逻辑或运算符
    - `||`（逻辑或）
    - **结合性**：左结合

15. 条件运算符
    - `?:`（三元条件）
    - **结合性**：**右结合**

16. 赋值运算符（优先级相同）
    - `=`
    - `+=`
    - `-=`
    - `*=`
    - `/=`
    - `%=`
    - `<<=`
    - `>>=`
    - `&=`
    - `^=`
    - `|=`
    - **结合性**：**右结合**

17. 逗号运算符
    - `,`（逗号）
    - **结合性**：左结合

**总的来说，算数运算先于逻辑运算先于赋值运算先于逗号。**

## 判断

判断结构要求程序员指定一个或多个要评估或测试的条件，以及条件为真时要执行的语句（必需的）和条件为假时要执行的语句（可选的）。

### 判断语句

C 语言提供了以下类型的判断语句：

1. if 语句
	```c
	if(boolean_expression)
	{
	   /* 如果布尔表达式为真将执行的语句 */
	}
	```
2. if...else 语句
	```c
	if(boolean_expression)
	{
	   /* 如果布尔表达式为真将执行的语句 */
	}
	else
	{
	   /* 如果布尔表达式为假将执行的语句 */
	}
	```

3. if...else if 语句
	```c
	if(boolean_expression1)
	{
	   /* 如果boolean_expression1表达式为真将执行的语句 */
	}
	else if (boolean_expression2) 
	{
		/* 如果boolean_expression1表达式为假
		 * 但boolean_expression2为真将执行的语句
		 */
	} 
	else
	{
	   /* 如果都为假将执行的语句 */
	}
	```

4. switch 语句
	```c
	switch(expression){ 
		case constant-expression : 
			statement(s); 
			break; /* 可选的 */ 
		case constant-expression : 
			statement(s); 
			break; /* 可选的 */ 
		/* 您可以有任意数量的 case 语句 */ 
		default : /* 可选的 */ 
			statement(s); 
	}
	```
**在每个 `case` 标签的代码块结束处通常需要使用 `break` 语句来终止 `switch` 语句的执行。如果没有 `break` 语句，程序将会继续执行下一个 `case` 标签中的代码，直到遇到 `break` 语句或 `switch` 语句结束。**

`if_else` 语句中若只有一句代码则大括号可缺省，且要注意的是：**C语言规定，在缺省大括号时，else 总是和上面离它最近的未配对的 if 相匹配，无论其缩进如何！！**
  

### ? : 运算符(三元运算符)

我们已经在前面的章节中讲解了条件运算符 `? :`，可以用来替代 `if...else` 语句。它的一般形式如下：

```c
Exp1 ? Exp2 : Exp3;
```

其中，Exp1、Exp2 和 Exp3 是表达式。请注意，冒号的使用和位置。

? 表达式的值是由 Exp1 决定的。如果 Exp1 为真，则计算 Exp2 的值，结果即为整个表达式的值。如果 Exp1 为假，则计算 Exp3 的值，结果即为整个表达式的值。

![](https://www.runoob.com/wp-content/uploads/2014/09/Conditional-Statement-in-C-Programming-Lanuage-Ternary-Operator.png)

## 循环

有的时候，我们可能需要多次执行同一块代码。一般情况下，语句是按顺序执行的：函数中的第一个语句先执行，接着是第二个语句，依此类推。

编程语言提供了更为复杂执行路径的多种控制结构：循环语句允许我们多次执行一个语句或语句组。

### 循环类型

C 语言提供了以下几种循环类型。

while 循环：

```c
while(condition)
{
   statement(s);
}
```

for 循环：

```c
for ( init; condition; increment ) 
{ 
	statement(s); 
}
```

**要注意的是，c语言for循环的小括号中是不允许定义变量的，可以初始化，但变量需要在外部定义。**

do...while 循环：

```c
do
{
   statement(s);

}while( condition );
```
除了它是在循环主体结尾测试条件外，其他与 while 语句类似，仔细地思考一下，你会发现除了它一开始会无条件执行循环体内的语句外，它跟 while 循环没有差别！


### 循环控制语句

循环控制语句改变你代码的执行顺序。通过它你可以实现代码的跳转。

C 提供了下列的循环控制语句。

`break;` ：1. 跳出当前循环体。 2. 终止 `switch` 中一个 case。

`continue;` ：continue 会跳过当前循环中的代码，强迫开始下一次循环。

**对于 for 循环，continue 语句执行后自增语句仍然会执行。对于 while 和 do...while 循环，continue 语句只会重新执行条件判断语句，立刻停止本次循环迭代，重新开始下次循环迭代。**

![pESx01S.png](https://s21.ax1x.com/2025/01/02/pESx01S.png)

goto 语句：C 语言中的 goto 语句允许把控制无条件转移到同一函数内的被标记的语句。

**注意：在任何编程语言中，都不建议使用 goto 语句。因为它使得程序的控制流难以跟踪，使程序难以理解和难以修改。任何使用 goto 语句的程序可以改写成不需要使用 goto 语句的写法。**

```c
goto label;
..
.
label: statement;
```

在这里，`label` 可以是任何除 C 关键字以外的纯文本，它可以设置在 C 程序中 goto 语句的前面或者后面。

![](https://www.runoob.com/wp-content/uploads/2015/01/goto.png)
  
在这里，

### 无限循环

如果条件永远不为假，则循环将变成无限循环。for 循环在传统意义上可用于实现无限循环。由于构成循环的三个表达式中任何一个都不是必需的，您可以将某些条件表达式留空来构成一个无限循环。

```c
#include <stdio.h> 
int main() 
{ 
	for ( ; ; ) 
	{ 
		printf("该循环会永远执行下去！\n"); 
	} 
	return 0; 
}
```

当条件表达式不存在时，它被假设为真。您也可以设置一个初始值和增量表达式，但是一般情况下，C 程序员偏向于使用 `for(;;)` 结构来表示一个无限循环。

您可以在运行时按 Ctrl + C 键终止一个无限循环。

# 输入输出

接下来我们将学习一些输入输出相关的函数。

> Tips: 
> 
> 在我先前的学习过程中，记住一系列函数往往是一件令我头大的事，主要是搞不懂具体怎样在自己写程序时正确地使用它们。其实在学习一系列函数时，你只需要重点关注以下信息就能掌握它们的用法了：
> 
> 1. 函数的返回值类型，比如如果函数是 void 类型的，就说明你不能使用一个变量接收它的返回值。这样的函数往往要么就是用于输出一些信息之类的，要么就是它有个指针的参数使函数能修改传入参数相关变量中的一些东西。
> 2. 参数数量及类型，你得知道到底怎么往这个函数中传东西。
>
> 你也可以看到，我在笔记中记录一个函数时，除了它的具体功能外主要记录的其实也就是这些东西。
> 
> VScode 中，你可以在代码中按住 ctrl 并用左键单击一个函数的函数名来看系统源码中有关这个函数的这些信息——看源码是个好习惯！

## `getchar()` & `putchar()`

`int getchar(void)` 
: 从屏幕读取下一个可用的字符，并把它返回为一个整数。这个函数在同一个时间内只会读取一个单一的字符。您可以在循环内使用这个方法，以便从屏幕上读取多个字符。

`int putchar(int c)` 
: 把字符输出到屏幕上，并返回相同的字符。这个函数在同一个时间内只会输出一个单一的字符。您可以在循环内使用这个方法，以便在屏幕上输出多个字符。

请看下面的实例：

```c
#include <stdio.h> 

int main( ) 
{ 
	int c; 
	printf( "Enter a value :"); 
	c = getchar( ); 
	printf( "\nYou entered: "); 
	putchar( c ); 
	printf( "\n"); 
	return 0; 
}
```

当上面的代码被编译和执行时，它会等待您输入一些文本，当您输入一个文本并按下回车键时，程序会继续并只会读取一个单一的字符，显示如下：

```
Enter a value :runoob

You entered: r
```

## `gets()` & `puts()`

`char *gets(char *s)`
: 从 stdin 读取一行到 `s` 所指向的缓冲区，直到一个终止符或 EOF。

`int puts(const char *s)` 
: 把字符串 s 和一个尾随的换行符写入到 stdout。

```c
#include <stdio.h> 

int main( ) 
{ 
	char str[100]; 
	printf( "Enter a value :"); 
	gets(str); 
	printf( "\nYou entered: "); 
	puts(str); 
	return 0; 
}
```

当上面的代码被编译和执行时，它会等待您输入一些文本，当您输入一个文本并按下回车键时，程序会继续并读取一整行直到该行结束，显示如下：

```
Enter a value :runoob

You entered: runoob
```

## `scanf()` & `printf()`

`int scanf(const char *__format, ...)`
: 从标准输入流 stdin 读取输入，并根据提供的 format 来浏览输入。


`int printf (const char *__format, ...)`
: 把输出写入到标准输出流 **stdout** ，并根据提供的格式产生输出。

可以看到，无论是 `scanf()` 还是 `printf()` 函数，都有第一个参数 `format` 要求你给入一个字符串 *（`const char *`说明这是一个指向常量字符的指针。它表明指针指向的数据是不可修改的。）*。 这个 format 可以是一个简单的常量字符串，但是你可以分别指定 %s、%d、%c、%f 等来输出或读取字符串、整数、字符或浮点数。还有许多其他可用的格式选项，可以根据需要使用。

使用例：

```c
#include <stdio.h> 

int main() 
{ 
	float f; 
	printf("Enter a number: "); 
	// %f 匹配浮点型数据 
	scanf("%f",&f); 
	printf("Value = %f", f); 
	return 0; 
}
```

当上面的代码被编译和执行时，它会等待您输入一些文本，当您输入一个文本并按下回车键时，程序会继续并读取输入，显示如下：

```
Enter a value :runoob 123

You entered: runoob 123
```

在这里，应当指出的是，scanf() 期待输入的格式与您给出的 %s 和 %d 相同，这意味着您必须提供有效的输入，比如 "string integer"，如果您提供的是 "string string" 或 "integer integer"，它会被认为是错误的输入。另外，在读取字符串时，只要遇到一个空格，scanf() 就会停止读取，所以 "this is test" 对 scanf() 来说是三个字符串。

下面将会对如何写这些 % 标签作详细记录：

### `scanf()`

`scanf()` 中，你应该这样写一个 % 标签：

```
%[*][width][modifiers]type
```

具体讲解如下：

| 参数 | 描述 |
|--|--|
| * | 这是一个可选的星号，表示数据是从流 stream 中读取的，但是可以被忽视，即它不存储在对应的参数中。 |
| width | 这指定了在当前读取操作中读取的最大字符数。 |
| modifiers | 为对应的附加参数所指向的数据指定一个不同于整型（针对 d、i 和 n）、无符号整型（针对 o、u 和 x）或浮点型（针对 e、f 和 g）的大小： h ：短整型（针对 d、i 和 n），或无符号短整型（针对 o、u 和 x） l ：长整型（针对 d、i 和 n），或无符号长整型（针对 o、u 和 x），或双精度型（针对 e、f 和 g） L ：长双精度型（针对 e、f 和 g） |
| type | 一个字符，指定了要被读取的数据类型以及数据读取方式。具体参见下一个表格。 |


**scanf 类型说明符：**

| 类型 | 合格的输入 | 参数的类型 |
|--|--|--|
| a、A | 读入一个浮点值(仅 C99 有效)。 | float * |
| c | 单个字符：读取下一个字符。如果指定了一个不为 1 的宽度 width，函数会读取 width 个字符，并通过参数传递，把它们存储在数组中连续位置。在末尾不会追加空字符。 | char * |
| d | 十进制整数：数字前面的 + 或 - 号是可选的。 | int * |
| e、E、f、F、g、G | 浮点数：包含了一个小数点、一个可选的前置符号 + 或 -、一个可选的后置字符 e 或 E，以及一个十进制数字。两个有效的实例 -732.103 和 7.12e4 | float * |
| i | 读入十进制，八进制，十六进制整数 。 | int * |
| o | 八进制整数。 | int * |
| s| 字符串。这将读取连续字符，直到遇到一个空格字符（空格字符可以是空白、换行和制表符）。
 | char * |
| u | 无符号的十进制整数。 | unsigned int * |
| x、X | 十六进制整数。 | int * |
| p | 读入一个指针 。 |  |
| [] | 扫描字符集合 。 |  |
| % | 读 % 符号。 |  |

你可以指定输入的格式，假如说你这么写：

```c
int a;
scanf("a=%d", &a);
```

那么在程序运行后，你就必须输入 `a=[整数]` 而不是只输入一个整数才能成功给 `a` 赋值。这当然是有点麻烦了，所以我们通常不会这样指定输入格式。

注意这个函数的返回值是个 `int`：如果成功输入，该函数返回成功匹配和赋值的个数。如果到达文件末尾或发生读取错误，则返回常量 `EOF`（其值为-1）。

这里特别要注意：**如果你在`scanf`中传参`"%d"` 的话，由于函数在检测到空格或回车时就结束读取，剩下的空格或 `\n` 就不会被读到，这样如果你要连续写几条输入语句时就可能发生一些错误，因为剩下的那个 `\n` 可能会被之后紧跟的输入语句读到，而那个函数也是检测到空格或回车就结束读取，导致它只读了个 `\n` 。避免这种问题的方法就是传参`"%d\n"`，将多余的那个\n也读入。**

比方说：

```c
int n;
scanf("%d\n", &n); // 读取要加密的文本行数
int i;
for (i = 0; i < n; i++)
{
    char text[1001] = {0}; // 假设每行文本不超过999个字符
    int i = 0;
    gets(text);
    encrypt_text(text); // 加密文本
}
```

### `printf()`

`printf()` 中标签属性是 

```
%[flags][width][.precision][length]type
```

具体讲解如下：
    
| type（格式字符） | 意义 |
|--|--|
| a, A | 以十六进制形式输出浮点数(C99 新增)。实例`printf("pi=%a\n", 3.14);` 输出 `pi=0x1.91eb86p+1`。 |
| d | 以十进制形式输出带符号整数(正数不输出符号) |
| o | 以八进制形式输出无符号整数(不输出前缀0) |
| x,X | 以十六进制形式输出无符号整数(不输出前缀Ox) |
| u | 以十进制形式输出无符号整数 |
| f | 以小数形式输出单、双精度实数 |
| e,E | 以指数形式输出单、双精度实数 |
| g,G | 以%f或%e中较短的输出宽度输出单、双精度实数 |
| c | 输出单个字符 |
| s | 输出字符串 |
| p | 输出指针地址 |
| lu | 32位无符号整数 |
| llu | 64位无符号整数 |

| flags（标识） | 描述 |
|--|--|
| - | 在给定的字段宽度内左对齐，默认是右对齐（参见 width 子说明符）。 |
| + | 强制在结果之前显示加号或减号（+ 或 -），即正数前面会显示 + 号。默认情况下，只有负数前面会显示一个 - 号。 |
| 空格 | 如果没有写入任何符号，则在该值前面插入一个空格。 |
| # | 与 e、E 和 f 一起使用时，会强制输出包含一个小数点，即使后边没有数字时也会显示小数点。默认情况下，如果后边没有数字时候，不会显示显示小数点；与 g 或 G 一起使用时，结果与使用 e 或 E 时相同，但是尾部的零不会被移除。 |
| 0 | 在指定填充 padding 的数字左边放置零（0），而不是空格（参见 width 子说明符）。 |

<table>
	<tr>
		<th>width（宽度）</th>
		<th>描述</th>
	</tr>
	<tr>
		<td>(number)</td>
		<td>
			<p>
				要输出的字符的最小数目。
				如果输出的值短于该数，结果会用空格填充。
				如果输出的值长于该数，结果不会被截断。
			</p>
		</td>
	</tr>
	<tr>
		<td>*</td>
		<td>宽度在 format 字符串中未指定，但是会作为附加整数值参数放置于要被格式化的参数之前。</td>
	</tr>
</table>

<table>
	<tr>
		<th>.precision（精度）</th>
		<th>描述</th>
	</tr>
	<tr>
		<td>.number</td>
		<td>
			<p>
				对于整数说明符（d、i、o、u、x、X）：precision 指定了要写入的数字的最小位数。如果写入的值短于该数，结果会用前导零来填充。如果写入的值长于该数，结果不会被截断。精度为 0 意味着不写入任何字符。  
对于 e、E 和 f 说明符：要在小数点后输出的小数位数。  
对于 g 和 G 说明符：要输出的最大有效位数。  
对于 s: 要输出的最大字符数。默认情况下，所有字符都会被输出，直到遇到末尾的空字符。  
对于 c 类型：没有任何影响。  
当未指定任何精度时，默认为 1。如果指定时不带有一个显式值，则假定为 0。
			</p>
		</td>
	</tr>
	<tr>
		<td>.*</td>
		<td>精度在 format 字符串中未指定，但是会作为附加整数值参数放置于要被格式化的参数之前。</td>
	</tr>
</table>

| length（长度） | 描述 |
|--|--|
| h | 参数被解释为短整型或无符号短整型（仅适用于整数说明符：i、d、o、u、x 和 X）。 |
| l | 参数被解释为长整型或无符号长整型，适用于整数说明符（i、d、o、u、x 和 X）及说明符 c（表示一个宽字符）和 s（表示宽字符字符串）。 |
| L | 参数被解释为长双精度型（仅适用于浮点数说明符：e、E、f、g 和 G）。 |

如果成功，则返回写入的字符总数，否则返回一个负数。

# 指针

指针是 C 语言中非常强大的一个工具，学习 C 语言的指针既简单（迫真）又有趣。通过指针，可以简化一些 C 编程任务的执行，还有一些任务，如动态内存分配，没有指针是无法执行的。所以，学习指针是很有必要的。

## 什么是指针

每一个变量都有一个内存位置，每一个内存位置都定义了可使用 & 运算符访问的地址，它表示了在内存中的一个地址。

```c
#include <stdio.h> 
int main () 
{ 
	int var_runoob = 10; 
	int *p; // 定义指针变量 
	p = &var_runoob; 
	printf("var_runoob 变量的地址： %p\n", p); 
	return 0; 
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
var_runoob 变量的地址： 0x7ffeeaae08d8
```

![](https://www.runoob.com/wp-content/uploads/2014/09/c-pointer.png)

而指针的强大之处也就在于，我们可以通过使用它直接操作计算机的内存！

当我们说“某某值是一个指针”时，指针的意思就是某个内存地址 ，比如 *“某某表达式的值是个指针”* 或 *“某某函数返回一个指针”*。 指针变量是用来存放内存地址的变量，而大多数情况我们干脆将指针变量也简称为指针，比如说 *“`p` 是个指针”*。而指针变量存储某个地址我们就会说 *“指针指向某个地址”* ，或者它存储了某个变量的地址，这时我们还会说 *“指针指向某个变量”* 。**这里有两种不同含义的“指针”与“指向”，要记得在对应语境中理解它们的含义**。

## 使用指针

使用指针时会频繁进行以下几个操作：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。

就像其他变量或常量一样，必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为：

```c
type *var_name;
```

在这里，`type` 是指针的基类型，它必须是一个有效的 C 数据类型，`var_name` 是指针变量的名称。用来声明指针的星号 `*` 与乘法中使用的星号是相同的。但是，在这个语句中，**星号在这里是个指针定义符，用来指定一个变量是指针**。以下是有效的指针声明：

```c
int *ip; /* 一个整型的指针 */ 
double *dp; /* 一个 double 型的指针 */ 
float *fp; /* 一个浮点型的指针 */ 
char *ch; /* 一个字符型的指针 */
```

所有实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，对应指针的值的类型都是一样的，都是一个代表内存地址的长的十六进制数。不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。

`*` 不仅是指针定义符，还可被用作解引用符，假如 `p` 是个指针变量，那么 `*p` 就是这个指针变量中存储的地址所指向的值。除此外，我们还有 `&` 取地址符，用以取变量地址。

下面的实例涉及到了这些操作：

```c
#include <stdio.h> 
int main () 
{ 
	int var = 20; /* 实际变量的声明 */ 
	int *ip; /* 指针变量的声明 */ 
	ip = &var; /* 在指针变量中存储 var 的地址，或者说 ip 指向 var 的地址*/ 
	printf("var 变量的地址: %p\n", &var ); /* 在指针变量中存储的地址 */ 
	printf("ip 变量存储的地址: %p\n", ip ); /* 使用指针访问值 */ 
	printf("*ip 变量的值: %d\n", *ip ); 
	return 0; 
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
var 变量的地址: 0x7ffeeef168d8
ip 变量存储的地址: 0x7ffeeef168d8
*ip 变量的值: 20
```

## 新建指针与新建普通变量

在C语言中，当你声明一个普通的变量（比如`int`、`float`、`char`等），编译器会自动在栈上为这个变量分配内存空间。

例如：

```c
int x = 10; // x是一个普通的整型变量，编译器会在栈上为它分配空间
```

在这个例子中，`x`是一个整型变量，当你声明它并给它赋值时，编译器会在栈上为`x`分配足够的空间来存储一个整数值（通常是4个字节），并且将这个空间的值设置为10。

呃，等等，“在栈上分配” 是什么意思？

好的，来解释一下：栈（stack）是一种特殊的内存区域，用于存储函数的局部变量和执行上下文。当你的函数调用结束时，这些局部变量所占用的内存空间会自动被释放。

在计算机编程中，当我们说“在栈上自动分配”，就像是你在书桌上放一本书。计算机会自动为你管理这块空间，当你看完的时候（函数执行结束），计算机就会自动把书放回书架（释放栈上的空间），这样书桌上的空间就又空出来了，可以给下一本书使用。也就是说：当你需要一些空间来存放数据时，计算机会自动帮你在栈上找到一块空间，当你用完这块空间后，计算机会自动帮你清理，这样你就可以继续使用这块空间来存放其他数据了。

而当你声明一个指针变量时，情况略有不同。指针变量是用来存储另一个变量的内存地址的变量。当你声明一个指针变量时，编译器同样会在栈上为这个指针变量分配空间，但是这个空间只用来存储一个地址值，而不是用来存储你想要通过指针访问的数据。

例如：

```c
int *p; // p是一个整型指针变量，编译器会在栈上为它分配空间
```

在这个例子中，`p`是一个整型指针变量，编译器会在栈上为`p`分配足够的空间来存储一个地址值（通常是4个字节或8个字节，取决于系统的架构）。但是，这个空间并不直接用来存储整数值，而是用来存储指向整数值的地址，要是你不为 `p` 赋初值的话，这个空间所存储指向整数值的地址就是未知的，就是说你都不知道 `p` 往哪指了，倘若 `p` 不小心指向了一些不应更改的内存地址，然后你又在这时想访问和修改这个地址对应的值的话，那后果简直不敢想象啊……

**所以，如果你想通过指针变量`p`来存储一个整数值，一定需要为这个整数值分配内存空间，并且让`p`指向这个空间！** 这可以通过动态内存分配（如`malloc`）或者指向一个已经存在的变量来实现。

例如：

```c
int *p = malloc(sizeof(int)); // 动态分配内存空间，并让p指向这块空间
if (p != NULL) {
    *p = 10; // 通过指针p来访问和修改这块空间的值
}
```

或者：

```c
int x = 10;
int *p = &x; // p指向x的地址，这样p就可以通过x来访问和修改x的值
```

在这两个例子中，`p`指向了一个整数值的内存空间，这样你就可以通过`p`来访问和修改这个整数值。

**再强调一遍，如果你想通过指针来存储数据，要记得为它分配内存空间！！**

## NULL 指针

在变量声明的时候，如果没有确切的地址可以赋值，新建指针时为指针变量赋一个 NULL 值也是一个良好的编程习惯。赋为 NULL 值的指针被称为**空**指针。

NULL 指针是一个定义在标准库中的值为零的常量。

```c
#include <stdio.h> 
int main () 
{ 
	int *ptr = NULL; 
	printf("ptr 的地址是 %p\n", ptr ); 
	return 0; 
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
ptr 的地址是 0000000000000000
```

在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是操作系统保留的。然而，内存地址 0 有特别重要的意义，它表明该指针不指向一个可访问的内存位置。**但按照惯例，如果指针包含空值（零值），则假定它不指向任何东西。**

如需检查一个空指针，您可以使用 if 语句，如下所示：

```c
if(ptr) /* 如果 p 非空，则完成 */ 
if(!ptr) /* 如果 p 为空，则完成 */
```

## 不可返回？

你已经掌握 c 语言指针的基础了！这天，你尝试将指针变量应用到函数中……

```c
int* create_array() {
    int arr[3] = {1, 2, 3};
    return arr;
}


int main()
{
    int *arr = create_array();
    for (int i = 0; i < 3; i++) {
        printf("%d\n", arr[i]);
    }
}
```

**程序出现错误了，怎么可能？**

好吧，正如我们上文所述，你在函数中新建一个数组时，这个数组是一个局部变量，是会在函数执行完毕后被销毁的，所以你当然不能在函数中新建数组后返回。

那么问题又来了，像

```c
int create_num()
{
	int p = 3;
	return p;
}
```

这样的代码又为什么是合法且有用的呢？事实上，int 类型是 *值类型* ，这就意味这函数在返回时会返回它的值的完整副本

## 指针的算术运算

C 指针是一个用数值表示的地址。**因此，您可以对指针执行算术运算。可以对指针进行四种算术运算：++、--、+、-。**

假设 `ptr` 是一个指向地址 1000 的整型指针，是一个 32 位的整数，让我们对该指针执行下列的算术运算：

```c
ptr++
```

在执行完上述的运算之后，`ptr`将指向位置 1004，**因为 ptr 每增加一次，它都将指向下一个整数位置，即当前位置往后移 4 字节。这个运算会在不影响内存位置中实际值的情况下，移动指针到下一个内存位置。** 如果 `ptr` 指向一个地址为 1000 的字符，上面的运算会导致指针指向位置 1001，因为下一个字符位置是在 1001。

我们概括一下：

-   指针的每一次递增，它其实会指向下一个元素的存储单元。
-   指针的每一次递减，它都会指向前一个元素的存储单元。
-   指针在递增和递减时跳跃的字节数取决于指针所指向变量数据类型长度，比如 int 就是 4 个字节。

### 递增递减一个指针

递增一个指针意味着让指针指向下一个内存位置，指针的递增操作会根据指针所指向的数据类型进行适当的内存偏移。

我们喜欢在程序中使用指针代替数组，因为变量指针可以递增，而数组不能递增，数组可以看成一个指针常量。下面的程序递增变量指针，以便顺序访问数组中的每一个元素：

```c
#include <stdio.h> 
const int MAX = 3; 
int main () 
{ 
	// 定义一个整数数组 
	int var[] = {10, 100, 200}; 
	
	// 定义一个整数变量 i 和一个整数指针 ptr 
	int i, *ptr; 
	
	// 将指针 ptr 指向数组 var 的起始地址 
	ptr = var; 
	
	// 循环遍历数组 
	for ( i = 0; i < MAX; i++) 
	{ 
		// 打印当前指针 ptr 所指向的地址 
		printf("存储地址：var[%d] = %p\n", i, ptr ); 
		// 打印当前指针 ptr 所指向地址的值 
		printf("存储值：var[%d] = %d\n", i, *ptr ); 
		// 将指针 ptr 移动到下一个数组元素的位置 
		ptr++; 
	} 
	
	return 0; 
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
存储地址：var[0] = e4a298cc
存储值：var[0] = 10
存储地址：var[1] = e4a298d0
存储值：var[1] = 100
存储地址：var[2] = e4a298d4
存储值：var[2] = 200
```

递增字符指针：

```c
#include <stdio.h>  
  
int main() {  
	char str[] = "Hello";  
	char *ptr = str; // 指针指向字符串的第一个字符  
	  
	printf("初始字符: %c\n", *ptr); // 输出 H  
	  
	ptr++; // 递增指针，使其指向下一个字符  
	printf("递增后字符: %c\n", *ptr); // 输出 e  
	  
	return 0;  
}  
```

在这个示例中，`ptr++` 使指针从 `str[0]` 指向 `str[1]`。因为 ptr 是一个 char 类型指针，所以它递增时会移动 `sizeof(char)` 个字节，即 1 个字节。

当上面的代码被编译和执行时，它会产生下列结果：

```
初始字符: H
递增后字符: e
```

递增结构体指针:

```c
#include <stdio.h>  
  
struct Point {  
	int x;  
	int y;  
};  
  
int main() 
{  
	struct Point points[] = {{1, 2}, {3, 4}, {5, 6}};  
	struct Point *ptr = points; // 指针指向结构体数组的第一个元素  
	  
	printf("初始点: (%d, %d)\n", ptr->x, ptr->y); // 输出 (1, 2)  
	  
	ptr++; // 递增指针，使其指向下一个结构体  
	printf("递增后点: (%d, %d)\n", ptr->x, ptr->y); // 输出 (3, 4)  
	  
	return 0;  
}  
```

在这个示例中，`ptr++` 使指针从 `points[0]` 指向 `points[1]`。因为 `ptr` 是一个 struct Point 类型指针，所以它递增时会移动 `sizeof(struct Point)` 个字节。

当上面的代码被编译和执行时，它会产生下列结果：

```
初始点: (1, 2)
递增后点: (3, 4)
```

而递减一个指针意味着让指针指向前一个内存位置。和递增指针类似，指针的递减操作也会根据指针所指向的数据类型进行适当的内存偏移。

### 指针的比较

在 C 语言中，可以比较指针来确定它们的关系。指针比较主要用于确定两个指针是否指向相同的内存位置或确定一个指针是否位于另一个指针之前或之后。

指针可以用关系运算符进行比较，如`==`、`!=`、`<`、`>`、`<=` 和 `>=`。如果 p1 和 p2 指向两个相关的变量，比如同一个数组中的不同元素，则可对 p1 和 p2 进行大小比较。

以下是一些示例代码，展示了如何比较指针并输出结果。

指针相等比较：

```c
#include <stdio.h> 
int main() 
{ 
	int a = 5; 
	int b = 10; 
	int *ptr1 = &a; 
	int *ptr2 = &a; 
	int *ptr3 = &b; 
	
	if (ptr1 == ptr2) { 
		printf("ptr1 和 ptr2 指向相同的内存地址\n"); // 这行会被输出 
	} else { 
		printf("ptr1 和 ptr2 指向不同的内存地址\n"); 
	} 
	if (ptr1 != ptr3) { 
		printf("ptr1 和 ptr3 指向不同的内存地址\n"); // 这行会被输出 
	} else { 
		printf("ptr1 和 ptr3 指向相同的内存地址\n"); 
	} 
	return 0; 
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
ptr1 和 ptr2 指向相同的内存地址
ptr1 和 ptr3 指向不同的内存地址
```

指针大小比较：

```c
#include <stdio.h>  
  
int main() {  
	int arr[] = {10, 20, 30, 40, 50};  
	int *ptr1 = &arr[1]; // 指向 arr[1]，值为 20  
	int *ptr2 = &arr[3]; // 指向 arr[3]，值为 40  
	  
	if (ptr1 < ptr2) {  
		printf("ptr1 在 ptr2 之前\n"); // 这行会被输出  
	} else {  
		printf("ptr1 在 ptr2 之后或相同位置\n");  
	}  
	  
	if (ptr1 > ptr2) {  
		printf("ptr1 在 ptr2 之后\n");  
	} else {  
		printf("ptr1 在 ptr2 之前或相同位置\n"); // 这行会被输出  
	}  
	  
	return 0;  
}  
```

当上面的代码被编译和执行时，它会产生下列结果：

```
ptr1 在 ptr2 之前
ptr1 在 ptr2 之前或相同位置
```

遍历数组并比较指针:

```c
#include <stdio.h>  
  
int main() {  
	int arr[] = {10, 20, 30, 40, 50};  
	int *start = arr; // 指向数组的第一个元素  
	int *end = &arr[4]; // 指向数组的最后一个元素  
	int *ptr;  
	  
	for (ptr = start; ptr <= end; ptr++) {  
		printf("当前指针指向的值: %d\n", *ptr);  
	}  
	  
	return 0;  
}  
```

当上面的代码被编译和执行时，它会产生下列结果：

```
当前指针指向的值: 10
当前指针指向的值: 20
当前指针指向的值: 30
当前指针指向的值: 40
当前指针指向的值: 50
```

总而言之，

-   **相等比较 (`==` 和 `!=`)**: 用于判断两个指针是否指向相同的内存位置。
-   **大小比较 (`<`, `>`, `<=`, `>=`)**: 通常用于指针遍历数组或内存块时，判断一个指针是否在另一个指针之前或之后。

需要注意的是，指针比较只有在指向同一个数组或同一内存块时才有意义，否则行为未定义。

### 指针类型和地址

是的，我知道这一节的内容属实让人有些吃惊：指针居然还能参与运算？而且我们就只不过是把地址值加一，它刚刚好就指向了下一单元，不多不少，这是怎么做到的？

首先我们得明白地址的本质：地址是内存中一个特定位置的标识，通常以字节为单位。**在底层，所有的地址都是无类型的，它们只是内存中的一个位置。**

但是，指针是有类型的，指针的类型决定了指针指向的数据空间的大小。当你对指针进行加减运算时，编译器会根据指针的类型来决定如何进行运算。具体来说，编译器会将指针增加或减少其指向的数据类型的大小倍数。比如说，如果你有一个 `int` 类型的指针，并且你对它进行 `+1` 操作，编译器会将指针增加 `sizeof(int)` 个字节，因为 `int` 通常是4个字节；而如果你有一个 `char` 类型的指针，`ptr++` 会将 `ptr` 增加1个字节，因为 `char` 是1个字节。

```c
char *p_char = malloc(10); // 分配10字节
int *p_int = malloc(10);   // 分配10字节
p_char++;  // 增加1字节
p_int++;   // 增加4字节（或更多，取决于int的大小）
free(p_char);
free(p_int);
```
在上面的例子中，尽管`p_char`和`p_int`都指向了10字节的内存，但由于它们的类型不同，指针增加的步长也不同。`p_char`增加1字节，而`p_int`增加了`int`类型的大小，通常是4字节。

**我们可以说指针的类型规定了地址的寻址粒度，它决定了指针在进行算术操作时的增量！** 这种机制使得指针算术能够正确地导航内存，同时保持与数据类型一致的接口。

（呃，*寻址粒度* 基本上就是说一个地址对应多少位内存）


### **解引用右值？**

来看一段有点莫名奇妙的程序：

```c
#include <stdio.h>

int main() {
    char str[99] = "helloworld";
    char *p = str;
    while (*p)
        *p++ -= 32;
    puts(str);
    return 0;
}
```

输出：`HELLOWORLD`

可见这个函数的功能十分简单：将小写字母转大写。但这里有个东西让我很感兴趣，那就是这个 `*p++` 是怎么起作用的？

显然，`*p++` 的功能在于解引用指针 `p`，然后递增指针 `p` 的值，事实上也不难理解这里为什么会是这样一个顺序，你知道，`p++` 返回 `p` 原先的值，而且后缀运算符的优先级最高，不是吗？这里的 `*p++` 是与 `*(p++)` 等价的。不过诡异的是， `p++` 不是返回一个右值吗？解引用一个右值是怎么回事？

好吧，按照C语言的标准，右值本身是不能被解引用的，因为它们不绑定到一个具体的内存地址，因此没有“指向”的概念。然而，这里有一个特殊情况：**后置递增或递减运算符（`p++` 或 `p--`）返回的是一个右值，但这个右值实际上是一个解引用操作的合法操作数。这是因为后置递增或递减运算符返回的是递增或递减之前指针的值的一个副本，然后指针本身才递增或递减。这个返回值是一个临时的右值，但它代表了递增或递减之前的内存地址，因此可以被解引用。**

**严格来说，不是右值不能解引用，而是不能随意解引用一个不代表有效内存地址的右值。如果一个右值是一个有效的内存地址（如 `&a`），那么对它进行解引用是完全合法的。千万注意！！**

## 指向指针的指针……？

指向指针的指针是一种多级间接寻址的形式，或者说是一个指针链。通常，一个指针包含一个变量的地址。当我们定义一个指向指针的指针时，第一个指针包含了第二个指针的地址，第二个指针指向包含实际值的位置。

![C 中指向指针的指针](https://www.runoob.com/wp-content/uploads/2014/09/pointer_to_pointer.jpg)

一个指向指针的指针变量必须如下声明，即在变量名前放置两个星号。例如，下面声明了一个指向 int 类型指针的指针：

```c
int **var;
```

当一个目标值被一个指针间接指向到另一个指针时，访问这个值需要使用两个星号运算符，如下面实例所示：

![](https://www.runoob.com/wp-content/uploads/2014/09/c-pointerxxxxx.png)

```c
#include <stdio.h> 
int main () 
{ 
	int V; 
	int *Pt1; 
	int **Pt2; 
	V = 100; 

	/* 获取 V 的地址 */ 
	Pt1 = &V; 

	/* 使用运算符 & 获取 Pt1 的地址 */ 
	Pt2 = &Pt1; 

	/* 使用 pptr 获取值 */ 
	printf("var = %d\n", V ); 
	printf("Pt1 = %p\n", Pt1 ); 
	printf("*Pt1 = %d\n", *Pt1 ); 
	printf("Pt2 = %p\n", Pt2 ); 
	printf("**Pt2 = %d\n", **Pt2); 

	return 0; 
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
var = 100
Pt1 = 0x7ffee2d5e8d8
*Pt1 = 100
Pt2 = 0x7ffee2d5e8d0
**Pt2 = 100
```

# 内存管理

先前我们提到，指针变量存储地址，但地址本质上是无类型的，一个地址对应多大的内存实际上是不确定的，所以我们用指针变量的类型来规定指针所指向的内存空间的大小，事实上，我们也能为指针动态地分配内存。

C 语言为内存的分配和管理提供了几个函数。这些函数可以在 *<stdlib.h>* 头文件中找到。

`void *calloc(int num, int size)`
: 在内存中动态地分配 num 个长度为 size 的连续空间，并将每一个字节都初始化为 0。所以它的结果是分配了 `num * size` 个字节长度的内存空间，并且每个字节的值都是 0。

`void free(void *address)` 
: 该函数释放 address 所指向的内存块,释放的是动态分配的内存空间。

`void *malloc(int num)`
: 在堆区分配一块指定大小的内存空间，用来存放数据。这块内存空间在函数执行完成后不会被初始化，它们的值是未知的。

`void *realloc(void *address, int newsize)` 
: 该函数重新分配内存，把内存扩展到 `newsize`。

**注意：** 

1. `void *` 类型表示无类型的指针。C、C++ 规定 `void *` 类型可以通过类型转换强制转换为任何其它类型的指针。
2. **分配过的内存在使用完后一定要用 `free` 函数释放！ 如果分配了内存但没有正确释放，就会发生内存泄漏。长时间运行的程序可能会因为不断泄漏内存而耗尽可用内存。**
3. **……同时最好也相关的指针设置为 `NULL` 。** 如果指针被释放后没有被设置为 `NULL`，它仍然指向原来的内存地址，这可能会导致野指针问题，即指针指向一个已经被释放的内存区域。
4. 当系统内存不足时，`malloc` 和 `calloc` 函数会返回 `NULL` 指针。

动态分配内存的操作主要会应用在数组上：编程时，如果你预先知道数组的大小，那么定义数组时就比较容易。例如，一个存储人名的数组，它最多容纳 100 个字符，所以您可以定义数组，如下所示：

```c
char name[100];
```

但是，如果预先不知道需要存储的文本长度，例如你 想存储有关一个主题的详细描述。在这里，我们需要定义一个指针，该指针指向未定义所需内存大小的字符，后续再根据需求来分配内存，如下所示：

```c
#include <stdio.h> 
#include <stdlib.h> 
#include <string.h> 

int main() 
{ 
	char name[100]; 
	char *description; 

	strcpy(name, "Zara Ali"); 

	/* 动态分配内存 */ 
	description = (char *)malloc( 200 * sizeof(char) ); 
	if( description == NULL ) 
	{ 
		fprintf(stderr, "Error - unable to allocate required memory\n"); 
	} 
	else 
	{ 
		strcpy( description, "Zara ali a DPS student in class 10th"); 
	} 

	printf("Name = %s\n", name ); 
	printf("Description: %s\n", description ); 
	
	free(description);
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
Name = Zara Ali
Description: Zara ali a DPS student in class 10th
```

上面的程序也可以使用 `calloc()` 来编写，只需要把 malloc 替换为 calloc 即可，如下所示：

```c
calloc(200, sizeof(char));
```

当动态分配内存时，你有完全控制权，可以传递任何大小的值。而那些预先定义了大小的数组，一旦定义则无法改变大小。

或者，你可以通过调用函数 `realloc()` 来增加或减少已分配的内存块的大小。让我们使用 `realloc()` 和 `free()` 函数，再次查看上面的实例：

```c
#include <stdio.h> 
#include <stdlib.h> 
#include <string.h>
 
int main() 
{ 
	char name[100]; 
	char *description; 
	strcpy(name, "Zara Ali"); 

	/* 动态分配内存 */ 
	description = (char *)malloc( 30 * sizeof(char) ); 
	if( description == NULL ) 
	{ 
		fprintf(stderr, "Error - unable to allocate required memory\n"); 
	} 
	else 
	{ 
		strcpy( description, "Zara ali a DPS student."); 
	} 

	/* 假设您想要存储更大的描述信息 */ 
	description = (char *) realloc( description, 100 * sizeof(char) ); 
	if( description == NULL ) 
	{ 
		fprintf(stderr, "Error - unable to allocate required memory\n"); 
	} 
	else 
	{ 
		strcat( description, "She is in class 10th"); 
	} 

	printf("Name = %s\n", name ); 
	printf("Description: %s\n", description ); 

	/* 使用 free() 函数释放内存 */ 
	free(description); 
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
Name = Zara Ali
Description: Zara ali a DPS student.She is in class 10th
```

您可以尝试一下不重新分配额外的内存，`strcat()` 函数会生成一个错误，因为存储 `description` 时可用的内存不足。

## 返回指针

事实上，我们可能没太关注过动态分配的地址的作用域，使用动态分配的内存是在堆内存中而非栈内存中的，也就是说，**这时指针的指向的内存是不会随函数的结束而被清空的** ，这也是为什么必须使用 `free` 函数才能够释放这块内存。

所以说，

# 数组

C 语言支持 *数组* 数据结构，它可以存储一个固定大小的相同类型元素的顺序集合。数组是用来存储一系列数据，但它往往被认为是一系列相同类型的变量。

数组的声明并不是声明一个个单独的变量，比如 `runoob0、runoob1、...、runoob99`，而是声明一个数组变量，比如 runoob，然后使用 `runoob[0]、runoob[1]、...、runoob[99]` 来代表一个个单独的变量。

所有的数组都是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素。

![C 中的数组](https://www.runoob.com/wp-content/uploads/2014/09/c-arrays-2021-1-18-3.png)

数组中的特定元素可以通过索引访问，第一个索引值为 0。

C 语言还允许我们使用指针来处理数组，这使得对数组的操作更加灵活和高效。

![](https://www.runoob.com/wp-content/uploads/2014/09/c-array-2021-01-18-2.png)

## 声明数组

在 C 中要声明一个数组，需要指定元素的类型和元素的数量，如下所示：

```c
type arrayName [ arraySize ];
```

这叫做一维数组。`arraySize` 必须是一个大于零的整数常量，`type` 可以是任意有效的 C 数据类型。例如，要声明一个类型为 double 的包含 10 个元素的数组 `balance`，声明语句如下：

```c
double balance[10];
```

现在 _balance_ 是一个可用的数组，可以容纳 10 个类型为 double 的数字。

**声明数组时数组的大小必须是编译时已知的常量**，故此

```c
#define N 8
int a[N];
```

是合法的，而

```c
int n=10, a[n];
```

不合法，因为 `n` 不是常量。

## 初始化数组

在 C 中，您可以逐个初始化数组，也可以使用一个初始化语句，如下所示：

```c
double balance[5] = {1000.0, 2.0, 3.4, 7.0, 50.0};
```

大括号 `{ }` 之间的值的数目不能大于我们在数组声明时在方括号 `[ ]` 中指定的元素数目。

如果您省略掉了数组的大小，数组的大小则为初始化时元素的个数。因此，如果：

```c
double balance[] = {1000.0, 2.0, 3.4, 7.0, 50.0};
```

您将创建一个数组，它与前一个实例中所创建的数组是完全相同的。下面是一个为数组中某个元素赋值的实例：

```c
balance[4] = 50.0;
```

上述的语句把数组中第五个元素的值赋为 50.0。所有的数组都是以 0 作为它们第一个元素的索引，也被称为基索引，数组的最后一个索引是数组的总大小减去 1。以下是上面所讨论的数组的的图形表示：

![数组表示](https://www.runoob.com/wp-content/uploads/2014/09/c-arrays-2021-1-18-4.png)

下图是一个长度为 10 的数组，第一个元素的索引值为 0，第九个元素 runoob 的索引值为 8：

![](https://www.runoob.com/wp-content/uploads/2014/09/c-array-2021-01-18-2.png)

顺便提一下，如果你尝试声明一个大小为0的数组，比如 `int a[0];`，编译器会报错，因为它不符合C语言的规范。不过 `int a[] = {}` 这样声明一个空数组是可以通过编译的，虽然这样的声明也毫无意义。数组是用来存储多个元素的东西，大小为0的数组没有分配任何内存空间，这样的数组实际上没有任何用处，因为你不能在其中存储任何值或对其进行操作，没人会想尝试这么写，对吧？

……没人会的对吧？

## 访问数组元素

数组元素可以通过数组名称加索引进行访问。元素的索引是放在方括号内，跟在数组名称的后边。例如：

```c
double salary = balance[9];
```

上面的语句将把数组中第 10 个元素的值赋给 salary 变量。下面的实例使用了上述的三个概念，即，声明数组、数组赋值、访问数组：

```c
#include <stdio.h> 
int main () 
{ 
	int n[ 10 ]; 
	/* n 是一个包含 10 个整数的数组 */ 
	int i,j; 
	
	/* 初始化数组元素 */ 
	for ( i = 0; i < 10; i++ ) { 
		n[ i ] = i + 100; 
		/* 设置元素 i 为 i + 100 */ 
	} 
	
	/* 输出数组中每个元素的值 */ 
	for (j = 0; j < 10; j++ ) { 
		printf("Element[%d] = %d\n", j, n[j] ); 
	} 
	return 0; 
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
Element[0] = 100
Element[1] = 101
Element[2] = 102
Element[3] = 103
Element[4] = 104
Element[5] = 105
Element[6] = 106
Element[7] = 107
Element[8] = 108
Element[9] = 109
```

## 获取数组长度

**数组长度**即数组中的元素个数。很可惜 c 语言本身并没有什么可以直接取数组长度的函数之类的，不过可以使用 `sizeof` 运算符来获取数组的长度，例如：

```c
int numbers[] = {1, 2, 3, 4, 5};
int length = sizeof(numbers) / sizeof(numbers[0]);
```

就是用数组所占总字节数除以每个元素所占字节数（只用取首个元素所占字节数是因为数组中所有元素类型一致，故所有元素所占字节数相同）来得到数组的长度，很好理解吧。

然后你就能自己把这串式子封装为函数或是宏之类的东西了：

```c
#include <stdio.h>  
  
#define LENGTH(array) (sizeof(array) / sizeof(array[0]))  
  
int main() {  
	int array[] = {1, 2, 3, 4, 5};  
	int length = LENGTH(array);  
	  
	printf("数组长度为: %d\n", length);  
	  
	return 0;  
}  
```

以上实例输出结果为：

```
数组长度为: 5
```

看不懂？没事，后面的 *预处理器指令* 一节的内容中会有 `#define` 使用方法的详细说明。

对字符串或是 char 数组来说，还可以用`strlen`求解数组长度。


```c
char arr6[] = "abc";//没有定义元素个数，用双引号定义3个字符，末尾数组会自动加上结束标志（\0)
printf("length arr6 = %d\n", strlen(arr6));

char arr7 [10] = "abc";//定义10个元素个数，用双引号赋值三个字符串，其余7个元素均自动定义为\0
printf("length arr7 = %d\n", strlen(arr7));

char arr8 [10] = {'a', 'b', 'c'};//定义10个元素个数，用大括号和单引号赋值三个字符串，则数组只含有三个字符，剩余7个均为\0
printf("length arr8 = %d\n", strlen(arr8));

char arr9 [10] = {'a', 98, '98'};//char定义数组，元素中出现没有用单引号的数字，会根据ASCII码输出字符
printf("length arr9 = %d\n", strlen(arr9));

char arr10 [] = {'a', 'b', 'c'};//没有定义元素个数，用大括号定义字符串，数组的元素个数则只有三个，结尾没有数组结束标志(\0)
printf("length arr10 = %d\n", strlen(arr10));
```

![pESx5X4.png](https://s21.ax1x.com/2025/01/02/pESx5X4.png)

从arr6和arr7中可以看出，用双引号定义的字符串数组都能正确计算出数组长度。这是因为这两个数组的末尾都含有结束标志 `\0` 。

另外要注意的是，arr10输入了三个字符，但结果却是15个，这是 **因为在没有定义数组个数的时候，用大括号的形式赋值，结尾不会自动补充结束标志\0，导致这个结果是个随机数，strlen会在内存中一直计数，知道在内存中遇到了0才会停止计数。**

但是对比arr8和arr9，也是用了大括号赋值，但结果却是正确的，这是因为开始定义了数组的个数，没有初始化赋值的数组会默认赋值为0（与\0有一样的效果）。

而如果用strlen用来求int类型数组的长度，会发现strlen不能用了。

```c
int arr1 [10] = {0};//定义了元素个数，且给第一个元素赋值为0，则其他元素均为0
printf("length arr1 = %d\n", strlen(arr1));

int arr2 [10] = {1, 2, 3, 4, 5};//定义了元素个数，但只给前五个元素赋值，则后五个元素均为0
printf("length arr2 = %d\n", strlen(arr2));

int arr4 [10];//什么都不放，编译器会给数组的每个元素放置随机数。
printf("length arr4 = %d\n", strlen(arr4));
```

![pESxh1U.png](https://s21.ax1x.com/2025/01/02/pESxh1U.png)


## 数组名

在 C 语言中，**数组名相当于指向数组地址的一个常量指针，是个不可修改的左值**。当我们在声明和定义一个数组时，该数组名就代表着该数组的地址。

例如，在以下代码中：

```c
int myArray[5] = {10, 20, 30, 40, 50};
```

在这里，myArray 是数组名，它表示整数类型的数组，包含 5 个元素。myArray 也代表着数组的地址。

数组名本身是个不可修改的左值，意味着它的值是不能被改变的，一旦确定，就不能再指向其他地方。

我们可以使用 `&` 运算符来获取数组元素的地址，如下所示：

```c
int myArray[5] = {10, 20, 30, 40, 50};
int *ptr = &myArray[0]; // 或者直接写作 int *ptr = myArray;
```

在上面的例子中，ptr 指针变量被初始化为 myArray 首元素的地址。

哦，在这里像 `int *ptr = myArray` 这样写也能达到相同的效果。**事实上，在大多数表达式中，数组名会被隐式地转换为指向数组第一个元素的指针。**

虽然我们说数组名是个不可修改的左值，不过数组出现在函数的参数列表中时是个例外，**出现在函数参数列表中的数组名是个可被赋值的指针！**

```c
void printArray(int arr[], int size) {  
	for (int i = 0; i < size; i++) {  
		printf("%d ", arr[i]);   
	}  
}  
  
int main() {  
	int myArray[5] = {10, 20, 30, 40, 50};  
	printArray(myArray, 5); 
	// 将数组名传递给函数，正常来说，arr = myArray 是不合法的。
	return 0;  
}  
```

将数组名视作一个指针是一种很有用的理解，我们将在后面的 *指向数组的指针* 的相关内容中有更详细的讨论。

## 细节

在 C 中，数组是非常重要的，我们需要了解更多有关数组的细节。

### 数组的创建

现在来看一看创建数组的各种方式，以及创建数组时数据都是怎样存放在数组中的：

```c
int arr1 [10] = {0};//定义了元素个数，且给第一个元素赋值为0，则其他元素均为0
```

```c
int arr2 [10] = {1, 2, 3, 4, 5};//定义了元素个数，但只给前五个元素赋值，则后五个元素均为0
```

```c
int arr3 [10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};//定义了元素个数，且给所有元素均赋值
```

```c
int arr4 [10];//什么都不放，编译器会给数组的每个元素放置随机数。
```

```c
int arr5[] = {1, 2, 3};//不定义元素个数，给几个元素赋值就有几个元素。
```

可以看到，**如果你定义了数组的大小（也就是 `[]` 号里面写了数字），但是没有给任何元素赋值，那么这个数组的所有元素都默认为一个随机数！！！如果你定义了数组大小，但只给部分元素赋值，那么剩余元素的值默认为0！！！（见上面arr4和arr5）。**

**因此常用上面arr1的方式，给int型数组的全部元素设置默认值为0.**

char型的数组也差不多：

```c
char arr6[] = "abc";//没有定义元素个数，用双引号定义3个字符，末尾数组会自动加上结束标志（\0)
```

![pESx4cF.png](https://s21.ax1x.com/2025/01/02/pESx4cF.png)

```c
char arr7 [10] = "abc";//定义10个元素个数，用双引号赋值三个字符串，其余7个元素均自动定义为\0
```

![pESxfpT.png](https://s21.ax1x.com/2025/01/02/pESxfpT.png)

```c
char arr8 [10] = {'a', 'b', 'c'};//定义10个元素个数，用大括号和单引号赋值三个字符串，则数组只含有三个字符，剩余7个均为\0
```

![pEp9Jv8.png](https://s21.ax1x.com/2025/01/02/pEp9Jv8.png)

```c
char arr9 [10] = {'a', 98, '98'};//char定义数组，元素中出现没有用单引号的数字，会根据ASCII码输出字符
```

```c
char arr10[] = {'a', 'b', 'c'};//没有定义元素个数，用大括号定义字符串，数组的元素个数则只有三个，结尾没有数组结束标志(\0)
```

（要格外注意举例中arr10和arr6的不同。同样为插入abc三个字符，但是arr6结尾有\0，arr10却没有，这在下一步求解数组长度的时候有相当大的区别！！！）


### 多维数组

下面的声明创建了一个三维 5 . 10 . 4 整型数组：

```c
int threedim[5][10][4];
```

多维数组可以通过在括号内为每行指定值来进行初始化。下面是一个带有 3 行 4 列的数组。

```c
int a[3][4] = {  
 {0, 1, 2, 3} ,   /*  初始化索引号为 0 的行 */
 {4, 5, 6, 7} ,   /*  初始化索引号为 1 的行 */
 {8, 9, 10, 11}   /*  初始化索引号为 2 的行 */
};
```

内部嵌套的括号是可选的，下面的初始化与上面是等同的：

```c
int a[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11};
```

是的，多维数组实际上是在内存中开辟了一块连续的空间来存储数据的，所以这样的初始化是可行的。

新建一个一维数组时，我们可以像 `int a[] = {...}` 这样在定义数组时省略对其大小的声明，而在提供了初值列表的前提下，多维数组定义时可以不用指定第1维的数组长度，但其余维的长度必须指定，编译器会根据列出的元素个数自动确定第1维的长度。例如：

```c
int A[][2][3]={1,2,3,4,5,6,7,8,9,10,11,12};
//正确
int B[2][][3]={1,2,3,4,5,6,7,8,9,10,11,12};
//错误，只能省略第1维
int C[2][2][]={1,2,3,4,5,6,7,8,9,10,11,12};
//错误，只能省略第1维
```

### 指向数组的指针


在下面的声明中：

```c
double balance[50];
```

我们通常情况下会将 `balance` 视作一个指向 `&balance[0]` 的指针，即数组 balance 的第一个元素的地址。但由先前的讨论我们知 `balance` 只不过是在表达式中被隐式转换为了指向首元素的指针而已。

```c
double *p;
double balance[10];

p = balance;
```

**所以大多数时候我们就直接将数组名视为指向首元素的指针，而这个指针的类型就是首元素指针类型**， 这给我们带来很多有趣的东西，比如 `*(balance + 4)` 就是一种访问 `balance[4]` 数据的合法方式。甚至你可以反过来将普通的指针就看做一个数组名，这样`[]` 其实跟解引用符也没什么区别！**对于一个普通的指针 `p` 来说，`p[0]` 也是合法的，这与 `*p` 等价！**

（哦，不过你不能写出 `balance++` 这种语句，记住数组名是不可修改的左值！）

一旦您把第一个元素的地址存储在 `p` 中，您就可以使用 `*p`、`*(p+1)`、`*(p+2)` 等来访问数组元素。下面的实例演示了上面讨论到的这些概念：

```c
#include <stdio.h> 

int main () 
{ 
	/* 带有 5 个元素的整型数组 */ 
	double balance[5] = {1000.0, 2.0, 3.4, 17.0, 50.0}; 
	double *p; 
	int i; 

	p = balance; 

	/* 输出数组中每个元素的值 */
	printf( "使用指针的数组值\n"); 
	for ( i = 0; i < 5; i++ ) 
	{ 
		printf("*(p + %d) : %f\n", i, *(p + i) ); 
	} 
	
	printf( "使用 balance 作为地址的数组值\n"); 
	for ( i = 0; i < 5; i++ ) 
	{ 
		printf("*(balance + %d) : %f\n", i, *(balance + i) ); 
	} 
	
	return 0; 
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
使用指针的数组值
*(p + 0) : 1000.000000
*(p + 1) : 2.000000
*(p + 2) : 3.400000
*(p + 3) : 17.000000
*(p + 4) : 50.000000
使用 balance 作为地址的数组值
*(balance + 0) : 1000.000000
*(balance + 1) : 2.000000
*(balance + 2) : 3.400000
*(balance + 3) : 17.000000
*(balance + 4) : 50.000000
```

现在让我们考虑一下多维数组，它的数组名也可以看作是指向它首元素的指针，不过要注意按照我们的直觉写出

```c
int a[2][3];
int **p = a;
```

是错的。多维数组实质上就是存了数组的数组，像这里 `a` 的首元素类型其实是 `int [3]` 而不是 `int *`！！所以 `a` 实际上是被隐式转化为了 `int (*)[3]` 类型的指针，也就是说你应该这样用指针指向 a 这个数组：

```c
int (*p)[3] = a;
```

你还得注意 `int *p[3]` 跟 `int (*p)[3]` 的区别！**`int *p[3]` 是个指针数组，它声明了一组指向 int 类型数据的指针；而 `int (*p)[3]` 是数组指针，它声明了一个指向一个数组的指针！** 这给我们声明指针变量带来了一个启示，就是 **当你要声明指向某个类型数据的指针变量时，先想想如何声明一个普通变量，然后用 `(*p)` 来替换掉那个变量名，这样 `p` 就是指向那个类型数据的指针。**

### 作为形参的数组

如果你想要在函数中传递一个一维数组作为参数，必须以下面三种方式来声明函数形式参数，这三种声明方式的结果是一样的，因为每种方式都会告诉编译器将要接收一个整型指针。同样地，也可以传递一个多维数组作为形式参数。

方式 1：形式参数是一个指针

```c
void myFunction(int *param) { . . . }
```

方式 2：形式参数是一个已定义大小的数组：

```c
void myFunction(int param[10]) { . . . }
```

方式 3：形式参数是一个未定义大小的数组

```c
void myFunction(int param[]) { . . . }
```

将指针作为参数的操作还算好理解，事实上我个人认为需要详细分析一下的就是上面提到的方式 2 与方式 3 了：

首先，C语言在处理函数参数时，数组参数会被退化为指向其第一个元素的指针，所以 `void func(int a[10])` 的声明也并不是限制只能传入大小为10的数组，它可以传入任意大小的数组，这点上三种数组参数没有区别。

但是，如果指定了数组的大小，比如 `void func(int a[10])`，这表示函数 `func` 接受一个具有10个整数的数组作为参数。**编译器会根据这个信息来检查数组的大小，就可以在编译时检查数组操作是否越界（你可以安全地使用 `a[9]` 而不用担心越界）。** 而声明为 `void func(int a[])` 的情况，表示函数 `func` 接受一个整数数组作为参数，但是没有指定数组的大小。在这种情况下，**编译器不会检查数组的大小，函数内部如果不自己管理数组的大小，就可能发生越界访问的问题。** 而 `void func(int *a)` 更是本来就没将传入的参数当成数组来看待，更容易发生各种问题了。

所以虽然 `void func(int a[10])` 传入任意大小的数组也不会在编译时或运行时直接报错，但由于传入大小不为10的数组可能会导致越界访问或逻辑错误等问题，建议还是老老实实地传入大小为10的数组。

不过如果你需要在函数内部处理与数组大小相关的逻辑，就可以考虑以其他方式传递数组的大小，比如通过额外的参数：

```c
void func(int a[], int size);
```

这里 `size` 参数用于指定数组 `a` 的实际大小，这样函数内部就可以根据这个大小来安全地访问数组元素：

```c
#include <stdio.h>
void func(int a[], int size) {
    for (int i = 0; i < size; i++) {
        printf("%d ", a[i]);
    }
    printf("\n");
}
int main() {
    int arr1[5] = {1, 2, 3, 4, 5};
    int arr2[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    func(arr1, 5);
    func(arr2, 10);
    return 0;
}
```

### 作为返回值的数组

C 语言不允许返回一个完整的数组作为函数的参数。但是，您可以通过指定不带索引的数组名来返回一个指向数组的指针。（*我们会在之后讲解有关指针的知识，您可以先跳过这里，等了解了 C 指针的概念之后，再来学习这里的内容。*）

如果您想要从函数返回一个一维数组，您必须声明一个返回指针的函数，如下：

```c
int * myFunction() { . . . }
```

**另外，C 不支持在函数外返回局部变量的地址，除非定义局部变量为 static 变量。**


### 静态数组与动态数组

在 C 语言中，有两种类型的数组：

-   静态数组：编译时分配内存，大小固定。
-   动态数组：运行时手动分配内存，大小可变。

静态数组的生命周期与作用域相关，而动态数组的生命周期由程序员控制。

在使用动态数组时，需要注意合理地分配和释放内存，以避免内存泄漏和访问无效内存的问题。

----------

#### **静态数组**

静态数组是指在编译时确定大小的数组，其大小在程序运行期间不能改变。

在 C 语言中，静态数组的内存分配在栈区，通常使用方括号 [] 来定义。

静态数组的特点包括：

-   内存分配：静态数组的内存通常分配在栈上，随着函数的调用和返回而自动管理。
-   大小固定：在定义时指定大小，且在程序运行过程中不能更改。
-   效率：由于在栈上分配内存，访问速度较快。
-   生命周期：静态数组的生命周期始于其定义时。如果在函数内部定义，生命周期与函数的调用相同；如果在全局范围定义，生命周期贯穿整个程序运行。

静态数组的声明和初始化示例：

```c
int staticArray[5]; // 静态数组声明
int staticArray[] = {1, 2, 3, 4, 5}; // 静态数组声明并初始化
```

对于静态数组，可以使用 sizeof 运算符来获取数组长度，例如：

```c
int array[] = {1, 2, 3, 4, 5};
int length = sizeof(array) / sizeof(array[0]);
```

以上代码中 `sizeof(array)` 返回整个数组所占用的字节数，而 `sizeof(array[0])` 返回数组中单个元素的字节数，将两者相除，就得到了数组的长度。

以上是一个简单的静态数组实例：

```c
#include <stdio.h>  
  
int main() {  
	int staticArray[] = {1, 2, 3, 4, 5}; // 静态数组声明并初始化  
	int length = sizeof(staticArray) / sizeof(staticArray[0]);  
	  
	printf("静态数组: ");  
	for (int i = 0; i < length; i++) {  
		printf("%d ", staticArray[i]);  
	}  
	printf("\n");  
  
	return 0;  
}  
```

以上实例中，我们声明并初始化了一个静态数组 staticArray，它包含了 5 个整数元素，然后我们通过 sizeof 运算符，我们计算了静态数组的长度，并使用循环遍历并打印数组的元素。

输出结果：

```
静态数组: 1 2 3 4 5
```

----------

#### **动态数组**

动态数组是在运行时通过动态内存分配函数（如 `malloc` 和 `calloc`）手动分配内存的数组，这听起来就是个很灵活很好用的玩意，**不过我强烈建议你看完本笔记中 *内存管理* 的相关内容并熟悉了 `malloc` 和 `calloc` 等函数的操作再来尝试使用动态数组！**

动态数组特点如下：

-   内存分配：动态数组的内存空间在运行时通过动态内存分配函数手动分配，并存储在堆上。需要使用 `malloc`、`calloc` 等函数来申请内存，并使用 `free` 函数来释放内存。
-   大小可变：动态数组的大小在运行时可以根据需要进行调整。可以使用 `realloc` 函数来重新分配内存，并改变数组的大小。
-   生命周期：动态数组的生命周期由程序员控制。需要在使用完数组后手动释放内存，以避免内存泄漏。

动态数组的声明、内存分配和释放实例：

```c
int size = 5;
int *dynamicArray = (int *)malloc(size * sizeof(int)); // 动态数组内存分配
// 使用动态数组
free(dynamicArray); // 动态数组内存释放
```

动态分配的数组，可以在动态分配内存时保存数组长度，并在需要时使用该长度，例如：

```c
int size = 5; // 数组长度
int *array = malloc(size * sizeof(int));

// 使用数组

free(array); // 释放内存
```

以上代码我们使用 malloc 函数动态分配了一个整型数组，并将长度保存在变量 size 中。然后可以根据需要使用这个长度进行操作，在使用完数组后，使用 free 函数释放内存。

> 注意：动态数组的使用需要注意内存管理的问题，确保在不再需要使用数组时释放内存，避免内存泄漏和访问无效的内存位置。

以上是一个简单的动态数组使用实例：

```c
#include <stdio.h>  
#include <stdlib.h>  
  
int main() {  
	int size = 5;  
	int *dynamicArray = (int *)malloc(size * sizeof(int)); // 动态数组内存分配  
	  
	if (dynamicArray == NULL) {  
		printf("Memory allocation failed.\n");  
		return 1;  
	}  
	  
	printf("Enter %d elements: ", size);  
	for (int i = 0; i < size; i++) {  
		scanf("%d", &dynamicArray[i]);  
	}  
	  
	printf("Dynamic Array: ");  
	for (int i = 0; i < size; i++) {  
		printf("%d ", dynamicArray[i]);  
	}  
	printf("\n");  
	  
	free(dynamicArray); // 动态数组内存释放  
	  
	return 0;  
}  
```

以上实例中，我们首先声明了一个变量 `size` 来指定动态数组的大小。

然后使用 `malloc` 函数为动态数组分配内存，并通过 `sizeof` 运算符计算所需的内存大小。

接下来，通过循环和 `scanf` 函数，从用户输入中读取元素值并存储到动态数组中。

最后，使用循环遍历并打印动态数组的元素。在程序结束时，使用 `free` 函数释放动态数组所占用的内存。

请注意，在使用动态数组时，需要检查内存分配是否成功（即 `dynamicArray` 是否为 `NULL`），以避免在内存分配失败时发生错误。

# 函数

函数是一组一起执行一个任务的语句。每个 C 程序都至少有一个函数，即主函数 `main()` ，所有简单的程序都可以定义其他额外的函数。

您可以把代码划分到不同的函数中。如何划分代码到不同的函数中是由您来决定的，但在逻辑上，划分通常是根据每个函数执行一个特定的任务来进行的。

函数 *声明* 告诉编译器函数的名称、返回类型和参数。函数 *定义* 提供了函数的实际主体。

C 标准库提供了大量的程序可以调用的内置函数。例如，函数`strcat()` 用来连接两个字符串，函数 `memcpy()` 用来复制内存到另一个位置。

函数还有很多叫法，比如方法、子例程或程序，等等。

## 定义函数

C 语言中的函数定义的一般形式如下：

```c
return_type function_name( parameter list )
{
   body of the function
}
```

在 C 语言中，函数由一个函数头和一个函数主体组成。下面列出一个函数的所有组成部分：

-  返回类型：一个函数可以返回一个值。`return_type` 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，`return_type` 是关键字 `void`。
-   函数名称：这是函数的实际名称。函数名和参数列表一起构成了函数签名。
-  参数：参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为 **实际参数**。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。
-   函数主体：函数主体包含一组定义函数执行任务的语句。

例：`max()` 函数

```c
/* 函数返回两个数中较大的那个数 */ 
int max(int num1, int num2) 
{ 
	/* 局部变量声明 */ 
	int result; 
	if (num1 > num2) { 
		result = num1; 
	} else { 
		result = num2; 
	} 
	return result; 
}
```

注意，**函数在碰到 `return` 语句时就会结束并返回值** ，于是我们也可以这么改写：

```c
int max(int num1, int num2) 
{ 
	if (num1 > num2)
		return num1;	 
	else
		return num2; 
}
```

## 函数声明

函数声明会告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。

函数声明包括以下几个部分：

```c
return_type function_name( parameter list ); //注意有个分号！
```

针对函数 `max()`，以下是函数声明：

```c
int max(int num1, int num2);
```

**在函数声明中，参数的名称并不重要，只有参数的类型是必需的！** 因此下面也是有效的声明：

```c
int max(int, int);
```

**当您在一个源文件中定义函数且在另一个文件中调用函数时，函数声明是必需的。在这种情况下，您应该在调用函数的文件顶部声明函数。**

例如，假设你有一个函数定义在 `function.c` 文件中：

*function.c:*

```c
#include <stdio.h>

// 函数定义
void functionToBeCalled(int param) {
    printf("Function called with %d\n", param);
}
```

你可以在 `main.c` 文件中调用这个函数，但在调用之前，你需要在 `main.c` 中声明这个函数：

*main.c:*

```c
#include <stdio.h>

// 函数原型声明
void functionToBeCalled(int param);

int main() {
    // 调用在另一个文件中定义的函数
    functionToBeCalled(10);
    return 0;
}
```

另外，你不能在一个函数中再定义一个函数，**不过在一个函数中声明一个函数就是没问题的。**

```c
// 这样是可以的
void fa()
{
	void fb(int);
	...;
}

void fb(int)
{
	...;
}
```

```c
// 这样就不行
void fa()
{
	void fb(int)
	{
		...;
	}
	...;
}
```

**而且一个文件中，如果要在一个函数中调用另一个函数，那被调用的函数就得在调用它的语句前被声明或被定义。**

## 调用函数

创建 C 函数时，会定义函数做什么，然后通过调用函数来完成已定义的任务。

当程序调用函数时，程序控制权会转移给被调用的函数。被调用的函数执行已定义的任务，当函数的返回语句被执行时，或到达函数的结束括号时，会把程序控制权交还给主程序。

调用函数时，传递所需参数，如果函数返回一个值，则可以存储返回值。例如：

```c
#include <stdio.h> 
/* 函数声明 */ 
int max(int num1, int num2); 

int main () 
{ 
	/* 局部变量定义 */ 
	int a = 100; 
	int b = 200; 
	int ret; 
	/* 调用函数来获取最大值 */ 
	ret = max(a, b); 
	printf( "Max value is : %d\n", ret ); 
	return 0; 
} 

/* 函数返回两个数中较大的那个数 */ 
int max(int num1, int num2) 
{ 
	/* 局部变量声明 */ 
	int result; 
	if (num1 > num2) 
		result = num1; 
	else 
		result = num2; 
	return result; 
}
```

把 `max()` 函数和 `main()` 函数放一块，编译源代码。当运行最后的可执行文件时，会产生下列结果：

```
Max value is : 200
```



## 函数参数

如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的**形式参数**。

形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。

当调用函数时，有两种向函数传递参数的方式：

1. 传值调用

该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数不会影响实际参数。

2. 引用调用

通过引用传递方式，形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作。

传递指针可以让多个函数访问指针所引用的对象，而不用把对象声明为全局可访问。

```c
/* 函数定义 */
void swap(int *x, int *y)
{
   int temp;
   temp = *x;    /* 保存地址 x 的值 */
   *x = *y;      /* 把 y 赋值给 x */
   *y = temp;    /* 把 temp 赋值给 y */
  
   return;
}
```

## 递归

递归指的是在函数的定义中使用函数自身的方法。

举个例子：  

> 从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？"从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？'从前有座山，山里有座庙，庙里有个老和尚，正在给小和尚讲故事呢！故事是什么呢？……'"

语法格式如下：

```c
[return_type] recursion() 
{ 
	if ([满足退出条件])
	{
		...;
		return ...;
	}
	recursion(); /* 函数调用自身 */ 
} 

int main() 
{ 
	recursion(); 
}
```

C 语言支持递归，即一个函数可以调用其自身。**但在使用递归时，程序员需要注意定义一个从函数退出的条件，否则会进入无限递归，发生栈溢出异常。**

递归有很多经典的应用，像是图的遍历算法中的 *深度优先搜索（DFS）* 算法就使用到了递归，还有一些简单的比如计算一个数的阶乘、生成斐波那契数列，等等。

事实上，**所有可用递归实现的逻辑也可用循环来实现**，这是一个有被数学证明过的结论。由于每个函数运行时都会占据一定栈内存，递归函数又是个多次反复调用其自身的东西，所以它运行起来对资源的消耗可能是会比较大的，甚至递归次数过多就会有发生栈溢出异常的风险，所以实际应用中，最好少用递归，想办法将递归改为循环。

### 数的阶乘

下面的实例使用递归函数计算一个给定的数的阶乘：

```c
#include <stdio.h> 

double factorial(unsigned int i) 
{ 
	if(i <= 1) 
	{ 
		return 1; 
	} 
	return i * factorial(i - 1); 
} 

int main() 
{ 
	int i = 15; 
	printf("%d 的阶乘为 %f\n", i, factorial(i)); 
	return 0; 
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```c
15 的阶乘为 1307674368000.000000
```

### 斐波那契数列

下面的实例使用递归函数生成一个给定的数的斐波那契数列：

```c
#include <stdio.h> 

int fibonaci(int i) 
{ 
	if(i == 0) 
		return 0; 
	if(i == 1) 
		return 1; 
	return fibonaci(i-1) + fibonaci(i-2); 
} 

int main() 
{ 
	int i; 
	for (i = 0; i < 10; i++)  
		printf("%d\t\n", fibonaci(i)); 
	return 0; 
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
0    
1    
1    
2    
3    
5    
8    
13    
21    
34
```

## 函数指针

函数指针是指向函数的指针变量。

通常我们说的指针变量是指向一个整型、字符型或数组等变量，而函数指针是指向函数。

声明一个函数指针就像这样：

```c
int (* p)(int, int);
```

这看起来有点怪，它为什么不能像是

```c
int *p(int, int);
```

这样呢？因为你不加括号的话就只算是在定义一个返回 `int *` 类型数据的函数，而不是在定义一个指向返回 int 类型的的函数的指针变量，我们在 *指向数组的指针* 相关内容中提到过类似的情况不是吗？

函数指针可以像一般函数一样，用于调用函数、传递参数。以下实例就说明了函数指针的用法：

```c
#include <stdio.h> 

int max(int x, int y) 
{ 
	return x > y ? x : y; 
} 

int main(void) 
{ 
	// p 是函数指针
	int (* p)(int, int) = &max; // &可以省略
	//（看起来函数名也可像数组名那样看做是函数常量指针！）
	int a, b, c, d; 
	
	printf("请输入三个数字:"); 
	scanf("%d %d %d", &a, &b, &c); 
	
	// 与直接调用函数等价，d = max(max(a, b), c)
	d = p(p(a, b), c); 
	
	printf("最大的数字是: %d\n", d); 
	return 0; 
}
```

编译执行，输出结果如下：

```
请输入三个数字:1 2 3
最大的数字是: 3
```

## 回调函数

### 函数指针作为某个函数的参数

函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用的函数。

简单讲：回调函数是由别人的函数执行时调用你实现的函数。

> 以下是来自知乎作者常溪玲的解说：
> 
> 你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件。

好吧，这个解说看起来也挺莫名其妙的，总之看一下回调函数的应用示例你就明白了：

### 实例

实例中 `populate_array()` 函数定义了三个参数，其中第三个参数是函数的指针，通过该函数来设置数组的值。

实例中我们定义了回调函数 `getNextRandomValue()`，它返回一个随机值，它作为一个函数指针传递给 `populate_array()` 函数。

`populate_array()` 将调用 10 次回调函数，并将回调函数的返回值赋值给数组。

```c
#include <stdlib.h> 
#include <stdio.h> 

void populate_array(int *array, size_t arraySize, int (*getNextValue)(void)) 
{ 
	for (size_t i=0; i<arraySize; i++) 
		array[i] = getNextValue(); 
} 

// 获取随机值 
int getNextRandomValue(void) 
{ 
	return rand(); 
} 

int main(void) 
{ 
	int myarray[10]; 
	
	/* getNextRandomValue 不能加括号，否则无法编译，
	因为加上括号之后相当于传入此参数时传入了 int , 
	而不是函数指针*/ 
	populate_array(myarray, 10, getNextRandomValue); 
	
	for(int i = 0; i < 10; i++) { 
		printf("%d ", myarray[i]); 
	} 
	
	printf("\n"); 
	return 0; 
}
```

编译执行，输出结果如下：

```
16807 282475249 1622650073 984943658 1144108930 470211272 101027544 1457850878 1458777923 2007237709
```


## 可变参数

有时，您可能会碰到这样的情况，您希望函数带有可变数量的参数，而不是预定义数量的参数。

C 语言为这种情况提供了一个解决方案，它允许您定义一个函数，能根据具体的需求接受可变数量的参数。

声明方式为：

```c
int func_name(int arg1, ...);
```

其中，省略号 `...` 表示可变参数列表。

下面的实例演示了这种函数的使用：

```c
int func(int, ... ) 
{ 
	. . . 
} 

int main() 
{ 
	func(2, 2, 3); 
	func(3, 2, 3, 4); 
}
```

请注意，函数 `func()` 最后一个参数写成省略号，即三个点号（`...`），省略号之前的那个参数是 `int`，代表了要传递的可变参数的总数。为了使用这个功能，您需要使用 **stdarg.h** 头文件，该文件提供了实现可变参数功能的函数和宏。具体步骤如下：

-   定义一个函数，最后一个参数为省略号，省略号前面可以设置自定义参数。
-   在函数定义中创建一个 `va_list` 类型变量，该类型是在 *stdarg.h* 头文件中定义的。
-   使用 int 参数和 `va_start()` 宏来初始化 `va_list` 变量为一个参数列表。宏 `va_start()` 是在 stdarg.h 头文件中定义的。
-   使用 `va_arg()` 宏和 `va_list` 变量来访问参数列表中的每个项。
-   使用宏 `va_end()` 来清理赋予 `va_list` 变量的内存。

常用的宏有：

-   `va_start(ap, last_arg)`：初始化可变参数列表。`ap` 是一个 `va_list` 类型的变量，`last_arg` 是最后一个固定参数的名称（也就是可变参数列表之前的参数）。该宏将 `ap` 指向可变参数列表中的第一个参数。
    
-   `va_arg(ap, type)`：获取可变参数列表中的下一个 type 类型参数。`ap` 是一个 `va_list` 类型的变量，`type` 是下一个参数的类型。该宏返回类型为 `type` 的值，并将 `ap` 指向下一个参数。
    
-   `va_end(ap)`：结束可变参数列表的访问。`ap` 是一个 `va_list` 类型的变量。该宏将 `ap` 置为 `NULL`。

现在让我们按照上面的步骤，来编写一个带有可变数量参数的函数，并返回它们的平均值：

```c
#include <stdio.h> 
#include <stdarg.h> 

double average(int num,...) 
{ 
	va_list valist; 
	double sum = 0.0; 
	int i; 

	/* 为 num 个参数初始化 valist */ 
	va_start(valist, num); 

	/* 访问所有赋给 valist 的参数 */ 
	for (i = 0; i < num; i++) 
	{ 
		sum += va_arg(valist, int); 
	} 

	/* 清理为 valist 保留的内存 */ 
	va_end(valist); 

	return sum/num; 
} 

int main() 
{ 
	printf("Average of 2, 3, 4, 5 = %f\n", average(4, 2,3,4,5)); 
	printf("Average of 5, 10, 15 = %f\n", average(3, 5,10,15)); 
}
```

在上面的例子中，average() 函数接受一个整数 num 和任意数量的整数参数。函数内部使用 va_list 类型的变量 valist 来访问可变参数列表。在循环中，每次使用 `va_arg()` 宏获取下一个整数参数，并输出。最后，在函数结束时使用 va_end() 宏结束可变参数列表的访问。

当上面的代码被编译和执行时，它会产生下列结果。应该指出的是，函数 `average()` 被调用两次，每次第一个参数都是表示被传的可变参数的总数。省略号被用来传递可变数量的参数。

```
Average of 2, 3, 4, 5 = 3.500000
Average of 5, 10, 15 = 10.000000
```

要注意的是， `va_arg(ap, type)` 宏中的 type 不可指定为 `char` 、`short` 、`float`。因为调用不带原型声明或声明为变参的函数时，主调函数会在传递未显式声明的参数前对其执行 *缺省参数提升(default argument promotions)* ，将提升后的参数值传递给被调函数。

​ 提升操作如下：

- float 类型的参数提升为 double 类型
- char、short 和相应的 signed、unsigned 类型参数提升为 int 类型
- 若 int 类型不能容纳原值，则提升为 unsigned int 类型

# C 头文件

`printf()` 也许是我们一开始学 C 时就会使用的函数了，但是仔细一想，我们用它的时候也没定义它，它是在哪里被声明与定义的呢？事实上如果我们有心去翻看一下 *stdio.h* —— 就是在开头 `#include` 后面那里写的那玩意，对，那是个文件，在 vscode 中用 <kbd>ctrl + 左键</kbd> 单击一下那个文件名就能查看它的内容了——你会发现 `printf()` 就定义在那里。这让我们不禁产生了一个想法：我们可不可以像引用 *stdio.h* 一样通过在程序中引用 .h 文件来使用一些被别人定义好了的各种函数，以简化我们的开发呢？答案是可以的。

这种扩展名为 .h 的文件就是所谓的 **头文件**，它包含了 *C 函数声明和宏定义* ，可以被多个源文件引用共享。有两种类型的头文件：程序员编写的头文件和编译器自带的头文件。

在程序中要使用头文件，需要使用 C 预处理指令 `#include` 来引用它。前面我们已经看过 `stdio.h` 头文件，它是编译器自带的头文件。

实际项目开发中建议把所有的常量、宏、系统全局变量和函数原型写在头文件中，在需要的时候随时引用这些头文件。

## #include

使用预处理指令 `#include` 可以引用用户和系统头文件。它的形式有以下两种：

```c
#include <file> 
// 这种形式用于引用系统头文件，它在系统目录的标准列表中搜索名为 file 的文件。
#include "file" 
// 而这种形式用于引用用户自定义头文件，它在包含当前文件的目录中搜索名为 file 的文件。
```

引用头文件相当于复制头文件的内容，`#include` 命令的作用在程序被编译前将该语句替换为头文件中的内容。但是我们不会直接在源文件中直接写头文件的内容，这样可能让代码前面塞满了一大堆函数或全局变量之类的东西的声明，使代码看起来十分冗长，而且在程序是由多个源文件组成的时候这样写还会容易出错，比如你可能把一个变量声明了两遍之类的。

我的意思是，如果你有一个头文件 *header.h*，内容如下：

```c
char *test(void);
```
和一个使用了头文件的主程序 _program.c_，如下：

```c
int x;
#include "header.h"

int main (void)
{
   puts(test());
}
```

编译器所看到的差不多就会是这样：

```c
int x;
char *test (void);

int main (void)
{
   puts(test());
}
```

除了 `#include` 之外 C 语言还有许多可以用来实现在编译前替换部分代码文本的语句，它们被称为 **预处理器指令** ，这个我们会在后文有详细记录。

## 标准库头文件

C 语言本体就提供了许多头文件供我们使用：C 标准库头文件（Standard Library Header Files）是由 ANSI C（也称为 C89/C90）和 ISO C（C99 和 C11）标准定义的一组头文件，这些头文件提供了大量的函数、宏和类型定义，用于处理输入输出、字符串操作、数学计算、内存管理等常见的编程任务。

以下是一些常见的 C 标准库头文件及其功能简介：

| 头文件 | 功能简介 |
|--|--|
| **<stdio.h>** | 标准输入输出库，包含 `printf`、`scanf` 等函数 |
| **<stdlib.h>** | 标准库函数，包含内存分配、程序控制等函数 |
| **<string.h>** | 字符串操作函数，如 `strlen`、`strcpy` 等 |
| **<math.h>** | 数学函数库，如 `sin`、`cos`、`sqrt` 等 |
| **<time.h>** | 时间和日期函数，如 `time`、`strftime` 等 |
| **<ctype.h>** | 字符处理函数，如 `isalpha`、`isdigit` 等 |
| **<limits.h>** | 定义各种类型的限制值，如 `INT_MAX` 等 |
| **<float.h>** | 定义浮点类型的限制值，如 `FLT_MAX` 等 |
| **<assert.h>** | 断言宏 `assert`，用于调试检查 |
| **<errno.h>** | 定义错误码变量 `errno` 及相关宏 |
| **<stddef.h>** | 定义通用类型和宏，如 `size_t`、`NULL` 等 |
| **<signal.h>** | 处理信号的函数和宏，如 `signal` 等 |
| **<setjmp.h>** | 提供非本地跳转功能的宏和函数 |
| **<locale.h>** | 地域化相关的函数和宏，如 `setlocale` 等 |


## 自定义头文件

既然我们可以使用别人写的 .h 文件，那么能不能自己写个 .h 文件呢？可以！

首先，我们可能会想：引用头文件不就是为了使用一些函数，全局变量，常量之类的东西的嘛，这还不简单，我们只要像

```c
#include <stdio.h>

const int MY_AGE = 114514;

int arr[];

void sayHello()
{
	printf("hello!");
}
```

这样按普通的方式在比如 *myheader.h* 中写出来，然后在其他地方 `#include "myheader.h"` 就好了，对吧？

**但很可惜事情并没有这么简单！** 我们知道引用本质上其实也就是文本替换，这样假如说你引用了两遍这个头文件，那也就相当于将头文件内的这些东西定义了两遍，这显然是不符合 c 语言的语法的，所以事实上我们要使用一些预处理器指令防止头文件内容的重复包含，像这样：

```c
#ifndef MYHEADER_H
#define MYHEADER_H

#include <stdio.h>

const int MY_AGE = 114514;

int arr[];

void sayHello()
{
printf("hello!");
}

#endif
```


这里使用到了 `#ifndef` 等指令（会在后文 *预处理器指令* 中有详细记录），在这里的它们的意思是：如果没定义过 `MYHEADER_H` 的话，就编译 `#ifndef` 和 `#endif` 包住的内容，也就是先定义一遍 `MYHEADER_H` 然后再加上你要添加到头文件之中的内容，当再次引用头文件时，条件为假，因为 `MYHEADER_H` 已定义。此时，预处理器会跳过文件的整个内容，编译器会忽略它。

这样就行了……吗？

其实通常来说，**我们编写头文件时要遵守声明与定义分离的原则**。也就是说头文件只用于声明函数、变量等，另外还要有一个对应的 .c 源文件来用于实现函数、给变量赋具体值等。

为什么这么做呢？因为虽然 `ifndef-endif` 可以防止头文件中的宏定义和变量声明被重复，但对于函数与全局变量来说，即使使用了`ifndef-endif` ，如果需要编译的源文件不止一个，而且它们都引用了这个头文件，那么在链接阶段，链接器还是会发现同一个函数或全局变量被重复定义，从而导致链接错误。而 `const` 修饰的全局变量在C语言中通常被视为只读数据。在某些编译器和链接器实现中，这些常量可能会被放在只读数据段中，这样使用`ifndef-endif` 后就不不会产生链接错误。但这只是对某些编译器和链接器而言的，将 `const` 修饰的全局变量视为只读数据并不是标准C语言的行为，不同的编译器和平台可能会有不同的处理方式。所以最好的做法是避免在头文件中定义 `const` 修饰的全局变量，而是使用 `#define` 来定义常量。而且将声明与定义分离还十分有助于代码的模块化和可维护性！

所以综上所述，如果我们需要在头文件中包含函数，我们只能在其中写函数的声明；如果需要全局变量，我们只能声明一个 `extern` 全局变量；而如果需要常量，我们只能使用 `#define` 宏定义而不是使用 `const` 。然后新建一个 .c 源文件来实现函数或是初始化全局变量，就像这样：

*myheader.h* :

```c
#ifndef MYHEADER_H
#define MYHEADER_H

#define MY_AGE 114514

extern int arr[];

void sayHello();

#endif
```

然后还有个 *myheader.c* :

```c
#include <stdio.h>
#include "myheader.h"

int arr[] = {0};

void sayHello()
{
	printf("hello");
}
```

这样我们就成功自定义一个头文件了！

……但是我们调用了这个头文件后编译运行这个程序后怎么还是会报错？

是的，除了把头文件写好外，你还得学会正确编译文件才能使它起作用……很麻烦吧？

### 编译程序

在尚未接触 vscode 之类的东西时，我们尚且是在命令行中打出

```bash
gcc hello.c
```

这样的指令来编译程序的，在编译完程序后我们随即就可以在命令行中打下 `hello` 来让它运行，然后我们一看存源代码的地方，就会发现那里多了一个跟源文件名同名的 .exe 文件，如果你会好奇地点一下它，就会发现那个 .exe 文件将我们写的代码运行了一遍……什么？你说只是出现了一个黑框然后马上就消失了？啊，那是因为 main 函数执行完了自动退出了，只要你想办法将 main 函数停在 `return 0` 之前，你就会看到那个 .exe 文件确实就是源代码的运行文件（顺带一提，"exe" 是 "execution（执行）" 的缩写）。至于怎么把 main 函数停在 `return 0` 之前，那就可以像这样：

```c
#include <stdio.h>
#include <windows.h>

int main()
{
	SetConsoleOutputCP(65001); // 这一句不是用来暂停的，它用来防止中文输出乱码
    printf("咋瓦鲁多！\n");
    system("pause");
    return 0;
}
```

咳，扯得有点远，但事实上，在命令行进入 .exe 文件所在的文件夹后再在其中打下 .exe 文件的文件名其实就是运行 .exe 文件。这就是为什么我们可以打下 `hello` 来运行代码，因为这实质上就是在运行 `hello.exe`。其实 `gcc` 指令也就是在运行 `gcc.exe` 文件，不信可以看看：记得配置 c 语言开发环境时你在系统环境变量中添加进去的那个 `mingw64\bin` 吗？在文件夹中打开那个路径，你就会发现那里就有 `gcc.exe` ！是的，一般我们要进入 .exe 文件所在的文件夹后才能运行这个文件，但只要将其所在目录写进环境变量中就无论在什么地方都能够执行这个 .exe 文件了，这也就是我们最开始要这么配置的原因。

`gcc.exe` 就是用来编译 .c 文件的一个程序，但显然我们不只是简单的将它运行一遍。除了打出 `gcc` 外，我们还要在后面跟上一些东西，比如先前看到的 `hello.c`。也就是说运行某些可执行文件的时候，我们还要指定一些参数！

再回想一下，我们 *编译 & 执行 C程序* 中还提到了怎么编译多个文件，像这样：

```bash
gcc test1.c test2.c -o main.exe
```

嗯对，我们运行运行某些可执行文件的时候还能指定各种选项！比如这里的 `-o <file>` 的意思就是指定输出的文件为某个文件（这个文件不存在的话就在当前路径中新建它）。

现在我们要编译自己写的 .c 文件（下文中会是 *testing.c*），于是我们尝试

```c
gcc testing.c
```

……要是真能这么容易就好了。事实上，我们还用到了自己编写的头文件对吧（比如下面会是 *person.h* 及其对应的 *person.c*，我在 *testing.c* 所在文件夹中新建了一个 *myheader* 文件夹并将 *person.h* 与 *person.c*放在了那里），所以我们就得像

```bash
gcc testing.c myheader/person.c -I myheader -o testing.exe
```

这样来编译这个文件！其中 `-I <dir>` 是用来添加头文件搜索路径的，要是没这句 gcc 就找不到 .h 在哪里从而报错（注意 `-I` 选项后面跟的是目录而不是具体文件哦）。

GCC/G++ 编译器选项还有很多，我会在下面列出网上找到的一些，感兴趣的话可以了解一下：

| 选项 | 含义 |
|--|--|
| `-o <file>` | 指定输出的文件名。 |
| `-E` | 只进行预处理，不进行编译和链接。 |
| `-S` | 编译并汇编，但不进行链接，输出汇编代码。 |
| `-c` | 编译并链接，但不生成最终的可执行文件，只生成目标文件（.o文件）。 |
| `-g` | 生成调试信息。 |
| `-O<level>` | 开启优化，`<level>` 可以是0、1、2、3，级别越高，优化程度越高。 |
| `-Os` | 开启空间优化。 |
| `-Wall` | 打开大多数警告信息。 |
| `-Wextra` | 打开额外的警告信息。 |
| `-Werror` | 将所有警告当作错误处理。 |
| `-pedantic` | 要求严格遵守C语言标准。 |
| `-std=<standard>` | 指定使用的C语言标准，如`c99`、`c11`、`gnu99`、`gnu11`等。 |
| `-fPIC` | 生成位置无关代码，用于生成共享库。 |
| `-shared` | 生成共享库（.so文件）。 |
| `-static` | 静态链接所有库。 |
| `-I<dir>` | 添加头文件搜索路径。 |
| `-L<dir>` | 添加库文件搜索路径。 |
| `-l<library>` |  链接指定的库。 |
| `-D<macro>` | 定义宏。 |
| `-U<macro>` | 取消宏定义。 |
| `-Wl,<option>` | 传递链接器选项。 |

好了，不管怎样，我们总算是能够编译自定义的头文件了，但每次编译运行都要像这样打一大串东西，这未免有些过于麻烦了。我们在先前在 VScode 中只要 `ctrl + f5` 就能编译运行文件，现在不能想点办法也让我们能够这么做吗？

当然是可以的！

### VScode 编译运行

事实上 VScode 本体只是一个代码编辑器而已，它只是能通过各种配置文件来增强对编程语言的支持，你还记得最初配置 C 语言开发环境时 *.vscode* 文件夹中的那些 .json 文件吗？对，那就是我所说的配置文件。VScode 无论是调试还是编译运行都离不开那些配置文件，也就是说，要让 VScode 成功编译你自己写的头文件，就得修改配置文件中的内s容。

首先我们要搞懂这些配置文件都是干嘛用的，这里我们主要要了解 *tasks.json*、*launch.json*、*c_cpp_properties.json* 三个文件，*tasks.json* 用来构建任务，对文件进行编译，*c_cpp_properties.json*  用来检查错误，*launch.json* 用来配置调试器。

如果你像我一样将 .h 文件放在要编译的 .c 文件目录的一个子目录中的话，你会发现 VScode 会报错，像这样：

![error1](https://s21.ax1x.com/2025/01/02/pESXllQ.png)

因为 VScode 在这个文件的同级目录中找不到 *person.h*，不过其实它能找到我同级的装*person.h* 的 *myheader* 的文件夹，所以只要像

![solu1](https://s21.ax1x.com/2025/01/02/pESX3Os.png)

这样的话就不会报错了。

事实上，VScode 是通过 *c_cpp_properties.json* 来寻找引用路径的，而且就是通过其中的 `includePath` 参数！所以我们也可以修改 *c_cpp_properties.json*  来让 VScode 能找到我们的头文件：

![sol2](https://s21.ax1x.com/2025/01/02/pESXj1g.png)

**注意 javaScript 数组字面量，也就是在那个方括号中，每一项间要用逗号隔开，花括号中也是。**

这里的 `${workspaceFolder}` 指的就是你的工作区目录（就是当前打开的文件夹），如果你存放头文件的文件夹不在工作区目录的子目录中，你可以直接用那个目录的绝对路径，或者使用其他类似 `${workspaceFolder}` 的东西，我在下面给出 .json 文件中各变量名所代表的含义，共参考，[查看来源](https://www.cnblogs.com/wanghao-boke/p/12058880.html)

| 变量名 | 含义 |
|--|--|
| ${workspaceRoot} | 当前打开的文件夹的绝对路径 |
| ${workspaceRootFolderName} | 当前打开的文件夹的名字 |
| ${file} | 当前打开正在编辑的文件名，包括绝对路径，文件名，文件后缀名 |
| ${relativeFile} | 从当前打开的文件夹到当前打开的文件的路径，如当前打开的是test文件夹，当前的打开的是main.c，并有test/first/second/main.c 那么此变量代表的是 first / second / main.c |
| ${fileBasename} | 当前打开的文件名+后缀名，不包括路径 |
| ${fileBasenameNoExtension} | 当前打开的文件的文件名，不包括路径和后缀名 |
| ${fileDirname} | 当前打开的文件所在目录的绝对路径，不包括文件名 |
| ${fileExtname} | 当前打开的文件的后缀名 |
| ${cwd} | 任务开始运行时的当前工作目录 |
| ${lineNumber} | 前打开的文件，光标所在的行数 |

然后为了成功编译，我们得修改 *tasks.json* 。首先我们这里使用 gcc 进行编译而不是用 g++ ，因为 g++ 是用来编译 c++ 语言的，跟 c 语言多少还是有点不一样，不过如果你先前一直在使用 g++ 的话也不会察觉到自己在用 g++ 就是了。这里你得看看 *tasks.json* 的 `task` 中有没有花括号里包着 `label: "C/C++: gcc.exe 生成活动文件"` 的一项（或 `label: "C/C++: gcc.exe build active file"`），若没有，则按快捷键 `Ctrl+Shift+P` 调出命令面板，输入 `tasks` ，选择 `“Tasks:Configure Default Build Task”`，再选择 `“C/C++: gcc.exe build active file（C/C++: gcc.exe 生成活动文件）”`，VScode 就会自动在 *tasks.json* 中帮你生成相关内容。

有了花括号里包着 `label: "C/C++: gcc.exe 生成活动文件"` 的一项，我们再像这样修改一下里面的内容

```javascript
{
	"type": "cppbuild",
	"label": "C/C++: gcc.exe 生成活动文件",
	"command": "D:\\installs\\mingw64\\bin\\gcc.exe",
	// 我们只需要改下面这一项！！！！
	"args": [
		"-fdiagnostics-color=always",
		"-g",
		"${file}",
		"${fileDirname}\\myheader\\*.c", // 添上这个
		"-o",
		"${fileDirname}\\${fileBasenameNoExtension}.exe",
		"-I",// 添上这个
		"${fileDirname}\\myheader"// 还有这个
	],
	// 之后都保持原样
	"options": {
		"cwd": "${fileDirname}"
	},
	"problemMatcher": [
		"$gcc"
	],
	"group": {
		"kind": "test",
		"isDefault": true
	},
	"detail": "编译器: D:\\installs\\mingw64\\bin\\gcc.exe"
}
```

**仔细看看，我们修改过的 `args` 中各项和我们之前提到的命令行指令 `gcc testing.c myheader/person.c -I myheader -o testing.exe` 中 `gcc` 后面跟着的那些各个参数都是一样的！**

是的，到这里其实就差不多了，但还要注意一下 *launch.json* 里有个 `preLaunchTask`，它的值应是 `"C/C++: gcc.exe 生成活动文件"` ，这样我们就完全可以用 VScode 编译运行带自己头文件的程序啦！

## 再谈标准库头文件

嗯，到这里我们好像完全搞懂了头文件是怎么一回事了，现在让我们再回过头看看标准库头文件吧：打开比如 *stdio.h* 这样的头文件，看，里面的每一段代码的含义你好像都能了然于心了（除了读不懂的英文注释还有那些诸如 `__attribute__` 之类的莫名其妙的玩意），搞懂这些东西的感觉实在是很美妙不是吗？想想看，参考一下这些函数的实现，比如`printf`，也许你也能够写出一段能将字符打印在屏幕上的代码……

***等一下，这些函数的实现在哪里？***

好吧，事实上标准库函数的实现不在 `.c` 文件中，不存在 `stdio.c` 这种东西，标准库函数的实现其实通常存储在编译器提供的库文件中，如 `libstdio.a` 或 `libmsvcrt.dll`（在Windows上），这些东西将会在 *基础编译原理* 中被详细讨论。

# 预处理器指令

**C 预处理器** 不是编译器的组成部分，但是它是编译过程中一个单独的步骤。事实上，C 预处理器只不过是一个文本替换工具而已，它们会指示编译器在实际编译之前完成所需的预处理。我们将把 C 预处理器（C Preprocessor）简写为 CPP。像我们之前学的引用头文件所使用的 `#include` 语句就是预处理器命令中的一个。

所有的预处理器命令都是以井号（`#`）开头，结尾不需要加分号（`;`），事实上，加上分号可能会导致编译错误。为了增强可读性，预处理器指令应从第一列开始。下面列出了所有重要的预处理器指令：

| 指令 | 描述 |
|--|--|
| #define | **宏定义（什么是“宏”？请看下文）** |
| #include | 包含一个源代码文件 |
| #undef | 取消已定义的宏 |
| #ifdef | 如果宏已经定义，则返回真 |
| #ifndef | 如果宏没有定义，则返回真 |
| #if | 如果给定条件为真，则编译下面代码 |
| #else | #if 的替代方案 |
| #elif | 如果前面的 #if 给定条件不为真，当前条件为真，则编译下面代码 |
| #endif |结束一个 #if……#else 条件编译块 |
| #error | 在编译时生成一个错误信息 |
| #pragma | 使用标准化方法，向编译器发布特殊的命令到编译器中 |

宏定义又称为宏代换、宏替换，简称 **“宏”**，是C提供的三种预处理功能的其中一种。简单地说，它的功能就是替换代码文本中的一些内容。在C语言中，它可以帮助程序员简化代码，避免重复编写相同的代码。

（`#pragma`指令是编译器特定的，不同的编译器可能对这些指令的支持不同。因此，在使用`#pragma`指令时，需要查阅你所使用的编译器的文档，了解它支持哪些指令以及如何使用这些指令。这条指令就不多记叙了。贴个文章在这：[【C语言进阶剖析】24、#pragma 使用分析-CSDN博客](https://blog.csdn.net/happyjacob/article/details/103218147)）

## 预处理器实例

分析下面的实例来理解不同的指令。

```c
#define MAX_ARRAY_LENGTH 20
```

这个指令告诉 CPP 把代码中所有的 “MAX_ARRAY_LENGTH” 替换为 “20”。

```c
#include <stdio.h>
#include "myheader.h"
```

这些指令告诉 CPP 从 **系统库** 中获取 *stdio.h*，并添加文本到当前的源文件中。下一行告诉 CPP 从 **本地目录** 中获取 *myheader.h*，并添加内容到当前的源文件中。

```c
#undef  FILE_SIZE
#define FILE_SIZE 42
```

这个指令告诉 CPP 取消已定义的 FILE_SIZE，并定义它为 42。

```c
#ifndef MESSAGE
   #define MESSAGE "You wish!"
#endif
```

这个指令告诉 CPP 只有当 MESSAGE 未定义时，才定义 MESSAGE。

```c
#ifdef DEBUG
   /* Your debugging statements here */
#endif
```

这个指令告诉 CPP 如果定义了 DEBUG，则执行处理语句。在编译时，如果您向 gcc 编译器传递了 _-DDEBUG_ 开关量，这个指令就非常有用。它定义了 DEBUG，您可以在编译期间随时开启或关闭调试。

```bash
gcc -DDEBUG example.c
```

```c
#ifndef __cplusplus
#error This code requires a C++ compiler.
#endif
```

这个例子中，`#error` 指令检查是否定义了 `__cplusplus` 宏。如果没有定义（通常意味着编译器不是 C++ 编译器），编译器会显示错误信息 "This code requires a C++ compiler."，并停止编译。如果尝试在不支持 C++ 的编译器（比如 C 编译器）中编译这段代码，编译器会报错并拒绝编译。这是一种确保代码兼容性的一种方式。

## 预定义宏

ANSI C 定义了许多宏。在编程中您可以使用这些宏，但是不能直接修改这些预定义的宏。

| 宏 | 描述 |
|--|--|
| `__DATE__` | 当前日期，一个以 "MMM DD YYYY" 格式表示的字符常量。 |
| `__TIME__` | 当前时间，一个以 "HH:MM:SS" 格式表示的字符常量。 |
| `__FILE__` | 这会包含当前文件名，一个字符串常量。 |
| `__LINE__` | 这会包含当前行号，一个十进制常量。 |
| `__STDC__` | 当编译器以 ANSI 标准编译时，则定义为 1。 |

让我们来尝试下面的实例：

```c
#include <stdio.h> 

int main() 
{ 
	printf("File :%s\n", __FILE__ ); 
	printf("Date :%s\n", __DATE__ ); 
	printf("Time :%s\n", __TIME__ ); 
	printf("Line :%d\n", __LINE__ ); 
	printf("ANSI :%d\n", __STDC__ ); 
}
```

当上面的代码（在文件 **test.c** 中）被编译和执行时，它会产生下列结果：

```
File :E:\workspace\CLearning\hello.c
Date :Nov 16 2024
Time :21:16:29
Line :8
ANSI :1
```

## 预处理器运算符

C 预处理器提供了下列的运算符来帮助您创建宏：

**宏延续运算符（\）**

一个宏通常写在一个单行上。但是如果宏太长，一个单行容纳不下，则使用宏延续运算符（\）。例如：

```c
#define  message_for(a, b)  \
    printf(#a " and " #b ": We love you!\n")
```

**字符串常量化运算符（#）**

在宏定义中，当需要把一个宏的参数转换为字符串常量时，则使用字符串常量化运算符（#）。在宏中使用的该运算符有一个特定的参数或参数列表。例如：

```c
#include <stdio.h> 
#define message_for(a, b) \
	printf(#a " and " #b ": We love you!\n") 
int main(void) 
{ 
	message_for(Carole, Debra); 
	return 0; 
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
Carole and Debra: We love you!
```

**标记粘贴运算符（##）**

宏定义内的标记粘贴运算符（##）会合并两个参数。它允许在宏定义中两个独立的标记被合并为一个标记。例如：

```c
#include <stdio.h> 
#define tokenpaster(n) printf ("token" #n " = %d", token##n) 

int main(void) 
{ 
	int token34 = 40; 
	tokenpaster(34); 
	return 0; 
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
token34 = 40
```

这是怎么发生的，因为这个实例会从编译器产生下列的实际输出：

```c
printf ("token34 = %d", token34);
```

这个实例演示了 token##n 会连接到 token34 中，在这里，我们使用了**字符串常量化运算符（#）**和**标记粘贴运算符（##）**。

**defined() 运算符**

预处理器 **defined** 运算符是用在常量表达式中的，用来确定一个标识符是否已经使用 `#define` 定义过。如果指定的标识符已定义，则值为真（非零）。如果指定的标识符未定义，则值为假（零）。下面的实例演示了 defined() 运算符的用法：

```c
#include <stdio.h> 
#if !defined (MESSAGE) 
#define MESSAGE "You wish!" 
#endif 

int main(void) 
{ 
	printf("Here is the message: %s\n", MESSAGE); 
	return 0; 
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
Here is the message: You wish!
```

## 参数化的宏

CPP 一个强大的功能是可以使用参数化的宏来模拟函数。例如，下面的代码是计算一个数的平方：

```c
int square(int x) {
   return x * x;
}
```

我们可以使用宏重写上面的代码，如下：

```c
#define square(x) ((x) * (x))
```

在使用带有参数的宏之前，必须使用 **#define** 指令定义。参数列表是括在圆括号内，且必须紧跟在宏名称的后边。宏名称和左圆括号之间不允许有空格。例如：

```c
#include <stdio.h> 
#define MAX(x,y) ((x) > (y) ? (x) : (y)) 

int main(void) 
{ 
	printf("Max between 20 and 10 is %d\n", MAX(10, 20)); 
	return 0; 
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
Max between 20 and 10 is 20
```

**要注意宏定义中被替换的那些 “形参” 参与运算时一定要带括号！** 因为宏定义本质上只是替换了相关的文本而已，实际运算时就有可能出现优先级问题。例如：

```c
#define sq(x) x * x
```

如果运行 `printf("%d", sq(2 + 1))` 的话，会输出 

```
5
```

也就是说，它算了 `2 + 1 * 2 + 1` 而非 `(2 + 1) * (2 + 1)`！

## 有条件引用

有时需要从多个不同的头文件中选择一个引用到程序中。例如，需要指定在不同的操作系统上使用的配置参数。您可以通过一系列条件来实现这点，如下：

```c
#if SYSTEM_1
   #include "system_1.h"
#elif SYSTEM_2
   #include "system_2.h"
#elif SYSTEM_3
   ...
#endif
```

# 存储类

存储类定义 C 程序中变量/函数的存储位置、生命周期和作用域。存储类的说明符放置在它们所修饰的类型之前。

我们的书桌上有各种各样的抽屉和盒子，每个抽屉和盒子都有不同的用途，用来存放不同的东西。其中有的抽屉可能用来放铅笔，有的盒子可能用来放橡皮，还有的可能用来放书本。这些抽屉和盒子就像是C语言中的“存储类”，它们决定了你的数据（比如变量）应该放在哪里，以及它们能在哪些地方被使用。

在C语言中，存储类就像是给变量分配的“抽屉”和“盒子”，它们有以下几个：

## 自动存储类（Auto）

**auto** 存储类是所有局部变量默认的存储类，**定义在函数中的变量默认为 auto 存储类**，这意味着它们在函数开始时被创建，在函数结束时被销毁。

就像书桌上用来放正在使用的铅笔的小盒子，这些铅笔只在你做作业的时候用，做完作业就放回去。在C语言中，自动存储类的变量就像这些铅笔，它们只在函数里面使用，函数结束后，这些变量就会被清除。

```c
{
   int mount;
   auto int month;
}
```

上面的实例定义了两个带有相同存储类的变量，**auto 只能用在函数内，即 auto 只能修饰局部变量。**

## 寄存器存储类（Register）

就像书桌上的一个特别的地方，用来放你经常需要用到的东西，比如你的橡皮。这样你就不用每次都去抽屉里找它了。在C语言中，寄存器存储类的变量就像这个特别的地方，它们被放在CPU的寄存器里，这样访问它们会更快。

register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。寄存器与 RAM 是两种不同的内存这意味着变量的最大尺寸等于寄存器的大小（通常是一个字），且不能对它应用一元的 '&' 运算符（因为它没有内存位置）。

register 存储类不能直接取地址，因为它不是存储在 RAM 中的。在需要频繁访问的变量上使用 register 存储类可以提高程序的运行速度。

```c
{
   register int  miles;
}
```

寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 'register' 并不意味着变量将被存储在寄存器中，它意味着变量 *可能* 存储在寄存器中，这取决于硬件和实现的限制。

## 静态存储类（Static）

就像你书桌上的大型抽屉，用来放你的书本和重要物品。这些物品会一直放在那里，即使你不用它们，它们也不会消失。在C语言中，静态存储类的变量就像这些书本，它们会一直存在，直到程序结束。

**static** 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。**因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。**

static 变量只能在声明它的文件内被访问，不能被外部文件访问。

static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。

全局声明的一个 static 变量或方法可以被任何函数或方法调用，只要这些方法出现在跟 static 变量或方法同一个文件中。

静态变量在程序中只被初始化一次，即使函数被调用多次，该变量的值也不会重置。

以下实例演示了 static 修饰全局变量和局部变量的应用：

```c
#include <stdio.h> /* 函数声明 */ 
void func1(void); 
static int count=10; /* 全局变量 - static 是默认的 */ 
int main() { 
	while (count--) { 
		func1(); 
	} 
	return 0; 
} 

void func1(void) { 
	/* 'thingy' 是 'func1' 的局部变量 - 只初始化一次 
	* 每次调用函数 'func1' 'thingy' 值不会被重置。 
	* */ 
	static int thingy=5; 
	thingy++; 
	printf(" thingy 为 %d ， count 为 %d\n", thingy, count); 
}
```

实例中 count 作为全局变量可以在函数内使用，thingy 使用 static 修饰后，不会在每次调用时重置。

可能您现在还无法理解这个实例，因为我已经使用了函数和全局变量，这两个概念目前为止还没进行讲解。即使您现在不能完全理解，也没有关系，后续的章节我们会详细讲解。当上面的代码被编译和执行时，它会产生下列结果：

```
 thingy 为 6 ， count 为 9
 thingy 为 7 ， count 为 8
 thingy 为 8 ， count 为 7
 thingy 为 9 ， count 为 6
 thingy 为 10 ， count 为 5
 thingy 为 11 ， count 为 4
 thingy 为 12 ， count 为 3
 thingy 为 13 ， count 为 2
 thingy 为 14 ， count 为 1
 thingy 为 15 ， count 为 0
```

也可用 static 修饰函数，使函数不可被外部文件调用。

## 外部存储类（Extern）

就像你把一些不常用的书放在书架上，这些书不仅在你的房间里有，在客厅或者其他房间也有。在C语言中，外部存储类的变量就像标注要用到这些书的一个便签。就像书可以在不同的房间里被阅读一样，我们可以在任何不同文件中通过这个便签找到并使用这些书（在其他地方已被定义好了的变量）。

**extern** 存储类用于定义在其他文件中声明的全局变量或函数。**当使用 extern 关键字时，不会为变量分配任何存储空间，而只是指示编译器该变量在其他文件中定义。**

`extern` 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 `extern` 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。

当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 `extern` 来得到已定义的变量或函数的引用。可以这么理解，`extern` 是用来在另一个文件中声明一个全局变量或函数。

extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候，如下所示：

*第一个文件：main.c*

```c
#include <stdio.h> 
int count ; 
extern void write_extern(); 

int main() { 
	count = 5; 
	write_extern(); 
}
```

*第二个文件：support.c*

```c
#include <stdio.h> 
extern int count; 

void write_extern(void) { 
	printf("count is %d\n", count); 
}
```

在这里，第二个文件中的 _extern_ 关键字用于声明已经在第一个文件 main.c 中定义的 _count_。现在 ，编译这两个文件，如下所示：

```
$ gcc main.c support.c
```

这会产生 *a.out* 可执行程序，当程序被执行时，它会产生下列结果：

```
count is 5
```

# 特别的类型

## 枚举

**枚举** 是 C 语言中的一种基本数据类型，用于定义一组具有离散值的常量，它可以让数据更简洁，更易读。

枚举类型通常用于为程序中的一组相关的常量取名字，以便于程序的可读性和维护性。

定义一个枚举类型，需要使用 `enum` 关键字，后面跟着枚举类型的名称，以及用大括号 {} 括起来的一组枚举常量。每个枚举常量可以用一个标识符来表示，也可以为它们指定一个整数值，如果没有指定，那么默认从 0 开始递增。

枚举语法定义格式为：

```c
enum　枚举名　{枚举元素1,枚举元素2,……};
// 注意有分号！！！
```

接下来我们举个例子，比如：一星期有 7 天，如果不用枚举，我们需要使用 `#define` 来为每个整数定义一个别名：

```c
#define MON 1 
#define TUE 2 
#define WED 3 
#define THU 4 
#define FRI 5 
#define SAT 6 
#define SUN 7
```

这个看起来代码量就比较多，接下来我们看看使用枚举的方式：

```c
enum DAY
{
      MON=1, TUE, WED, THU, FRI, SAT, SUN
};
```

这样看起来是不是更简洁了。

**注意：第一个枚举成员的默认值为整型的 0，后续枚举成员的值在前一个成员上加 1。我们在这个实例中把第一个枚举成员的值定义为 1，第二个就为 2，以此类推。**

> 可以在定义枚举类型时改变枚举元素的值：
> 
>` enum season {spring, summer=3, autumn, winter};`
> 
> 没有指定值的枚举元素，其值为前一元素加 1。也就说 spring 的值为 0，summer 的值为 3，autumn 的值为 4，winter 的值为 5

### 枚举变量的定义

前面我们只是声明了枚举类型，接下来我们看看如何定义枚举变量。

我们可以通过以下三种方式来定义枚举变量

**1、先定义枚举类型，再定义枚举变量**

```c
enum DAY
{
      MON=1, TUE, WED, THU, FRI, SAT, SUN
};
enum DAY day;
```

**2、定义枚举类型的同时定义枚举变量**

```c
enum DAY
{
      MON=1, TUE, WED, THU, FRI, SAT, SUN
} day;
```

**3、省略枚举名称，直接定义枚举变量**

```c
enum
{
      MON=1, TUE, WED, THU, FRI, SAT, SUN
} day;
```

实例：

```c
#include <stdio.h> 

enum DAY 
{ 
	MON=1, TUE, WED, THU, FRI, SAT, SUN 
}; 

int main() 
{ 
	enum DAY day; 
	day = WED; 
	printf("%d",day); 
	return 0; 
}
```

以上实例输出结果为：

```
3
```

在C 语言中，枚举类型是被当做 int 或者 unsigned int 类型来处理的，所以按照 C 语言规范是没有办法遍历枚举类型的。

不过在一些特殊的情况下，枚举类型必须连续是可以实现有条件的遍历。

以下实例使用 for 来遍历枚举的元素：

```c
#include <stdio.h> 
enum DAY 
{
	 MON=1, TUE, WED, THU, FRI, SAT, SUN 
} day; 

int main() 
{ 
	// 遍历枚举元素 
	for (day = MON; day <= SUN; day++) { 
		printf("枚举元素：%d \n", day); 
	} 
}
```

以上实例输出结果为：

```
枚举元素：1 
枚举元素：2 
枚举元素：3 
枚举元素：4 
枚举元素：5 
枚举元素：6 
枚举元素：7
```

以下枚举类型不连续，这种枚举无法遍历。

```c
enum
{
    ENUM_0,
    ENUM_10 = 10,
    ENUM_11
};
```

枚举在 switch 中的使用：

```c
#include <stdio.h> 
#include <stdlib.h> 

int main() 
{ 
	enum color 
	{ 
		red=1, green, blue 
	}; 
	enum color favorite_color; /* 用户输入数字来选择颜色 */ 

	printf("请输入你喜欢的颜色: (1. red, 2. green, 3. blue): "); 
	scanf("%u", &favorite_color); /* 输出结果 */ 

	switch (favorite_color) { 
		case red: 
			printf("你喜欢的颜色是红色"); 
			break; 
		case green: 
			printf("你喜欢的颜色是绿色"); 
			break; 
		case blue: 
			printf("你喜欢的颜色是蓝色"); 
			break; 
		default: 
			printf("你没有选择你喜欢的颜色"); 
	} 
	return 0; 
}
```

以上实例输出结果为：

```
请输入你喜欢的颜色: (1. red, 2. green, 3. blue): 1
你喜欢的颜色是红色
```

### 将整数转换为枚举

以下实例将整数转换为枚举：

```c
#include <stdio.h> 
#include <stdlib.h> 

int main() 
{ 
	enum day 
	{ 
		saturday, sunday, monday, tuesday, wednesday, thursday, friday 
	} workday; 

	int a = 1; 
	enum day weekend; 
	weekend = ( enum day ) a; //类型转换 
	//weekend = a; //错误 
	
	printf("weekend:%d",weekend); 
	return 0; 
}
```

以上实例输出结果为：

```
weekend:1
```

## 结构体

C 数组允许定义可存储相同类型数据项的变量，**结构**是 C 编程中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。

结构体中的数据成员可以是基本数据类型（如 int、float、char 等），也可以是其他结构体类型、指针类型等。

结构用于表示一条记录，假设您想要跟踪图书馆中书本的动态，您可能需要跟踪每本书的下列属性：

-   Title
-   Author
-   Subject
-   Book ID

### 定义结构

结构体定义由关键字 struct 和结构体名组成，结构体名可以根据需要自行定义。

struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下：

```c
struct tag {  
	member-list  
	member-list  
	member-list  
	...  
} variable-list ;  
```

`tag` 是结构体标签。

`member-list` 是标准的变量定义，比如 int i; 或者 float f;，或者其他有效的变量定义。

`variable-list` 结构变量，定义在结构的末尾，最后一个分号之前，您可以指定一个或多个结构变量。下面是声明 Book 结构的方式：

```c
struct Books  
{  
	char title[50];  
	char author[50];  
	char subject[100];  
	int book_id;  
} book;  
```

在一般情况下，`tag`、`member-list`、`variable-list` 这 3 部分至少要出现 2 个。以下为实例：

```c
//此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c  
//同时又声明了结构体变量s1  
//这个结构体并没有标明其标签  
struct  
{  
	int a;  
	char b;  
	double c;  
} s1;  
```

```c  
//此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c  
//结构体的标签被命名为SIMPLE,没有声明变量  
struct SIMPLE  
{  
	int a;  
	char b;  
	double c;  
};  
//用SIMPLE标签的结构体，另外声明了变量t1、t2、t3  
struct SIMPLE t1, t2[20], *t3;  
```

在C语言中，`typedef` 关键字用于为一个类型定义一个新的名称。当你使用 `typedef` 与 `struct` 结合时，你实际上是在定义一个结构体的同时为其创建了一个新类型名。这两者之间的实质区别主要体现在如何引用结构体上：

1.  **`struct T {...}`**：
    
    这种定义方式只是定义了一个名为 `T` 的结构体类型，但没有为它创建一个新的类型名。因此，如果你想创建这个结构体类型的变量，你需要在变量前加上 `struct` 关键字。
    例如：
        
	```c
	struct T {
		int a;
		float b;
	};

	struct T myStruct; // 正确：使用 struct 关键字
	T myStruct;       // 错误：不能这样使用，因为 T 只是一个结构体标签，不是一个类型名
	```
        
2.  **`typedef struct {...} T`**：
    
    这种定义方式不仅定义了一个结构体，而且还为这个结构体创建了一个新的类型名 `T`。这意味着你可以像使用基本数据类型一样使用 `T` 来声明变量，而不需要在前面加上 `struct` 关键字。
    例如：
        
	```c
	typedef struct {
		int a;
		float b;
	} T;

	T myStruct; // 正确：可以直接使用 T 作为类型名
	```
        

使用 `typedef` 的好处是代码更加简洁，当你声明变量时不需要每次都写 `struct` 关键字。此外，`typedef` 还可以用于为复杂的类型定义别名，比如指针类型、函数类型等，这使得代码更加清晰易读。

总结来说，`struct T {...}` 和 `typedef struct {...} T` 在功能上是相似的，它们都定义了一个结构体类型。不同之处在于 `typedef` 允许你为结构体创建一个新的类型名，使得在声明变量时更加方便。

```c
//也可以用typedef创建新类型  
typedef struct  
{  
	int a;  
	char b;  
	double c;  
} Simple2;  
//现在可以用Simple2作为类型声明新的结构体变量  
Simple2 u1, u2[20], *u3;  
```

不过，在上面的声明中，第一个和第二声明被编译器当作两个完全不同的类型，即使他们的成员列表是一样的，如果令 `t3=&s1`，则是非法的。

结构体的成员可以包含其他结构体，也可以包含指向自己结构体类型的指针，而通常这种指针的应用是为了实现一些更高级的数据结构如链表和树等。

```c
//此结构体的声明包含了其他的结构体  
struct COMPLEX  
{  
	char string[100];  
	struct SIMPLE a;  
};  
```

```c
//此结构体的声明包含了指向自己类型的指针  
struct NODE  
{  
	char string[100];  
	struct NODE *next_node;  
};  
```

如果两个结构体互相包含，则需要对其中一个结构体进行不完整声明，如下所示：

```c
struct B; //对结构体B进行不完整声明  
  
//结构体A中包含指向结构体B的指针  
struct A  
{  
	struct B *partner;  
	//other members;  
};  
  
//结构体B中包含指向结构体A的指针，在A声明完后，B也随之进行声明  
struct B  
{  
	struct A *partner;  
	//other members;  
};  
```

----------

### 结构体变量的初始化

和其它类型变量一样，对结构体变量可以在定义时指定初始值。

```c
#include <stdio.h>  
  
struct Books  
{  
	char title[50];  
	char author[50];  
	char subject[100];  
	int book_id;  
} book = {"C 语言", "RUNOOB", "编程语言", 123456};  
  
int main()  
{  
	printf("title : %s\nauthor: %s\nsubject: %s\nbook_id: %d\n", book.title, book.author, book.subject, book.book_id);  
}  
```

执行输出结果为：

```
title : C 语言
author: RUNOOB
subject: 编程语言
book_id: 123456
```

### 访问结构成员

为了访问结构的成员，我们使用**成员访问运算符（.）**。成员访问运算符是结构变量名称和我们要访问的结构成员之间的一个句号。您可以使用 **struct** 关键字来定义结构类型的变量。下面的实例演示了结构的用法：

```c
#include <stdio.h>  
#include <string.h>  
  
struct Books  
{  
	char title[50];  
	char author[50];  
	char subject[100];  
	int book_id;  
};  
  
int main( )  
{  
	struct Books Book1; /* 声明 Book1，类型为 Books */  
	struct Books Book2; /* 声明 Book2，类型为 Books */  
	  
	/* Book1 详述 */  
	strcpy( Book1.title, "C Programming");  
	strcpy( Book1.author, "Nuha Ali");  
	strcpy( Book1.subject, "C Programming Tutorial");  
	Book1.book_id = 6495407;  
	  
	/* Book2 详述 */  
	strcpy( Book2.title, "Telecom Billing");  
	strcpy( Book2.author, "Zara Ali");  
	strcpy( Book2.subject, "Telecom Billing Tutorial");  
	Book2.book_id = 6495700;  
	  
	/* 输出 Book1 信息 */  
	printf( "Book 1 title : %s\n", Book1.title);  
	printf( "Book 1 author : %s\n", Book1.author);  
	printf( "Book 1 subject : %s\n", Book1.subject);  
	printf( "Book 1 book_id : %d\n", Book1.book_id);  
	  
	/* 输出 Book2 信息 */  
	printf( "Book 2 title : %s\n", Book2.title);  
	printf( "Book 2 author : %s\n", Book2.author);  
	printf( "Book 2 subject : %s\n", Book2.subject);  
	printf( "Book 2 book_id : %d\n", Book2.book_id);  
	  
	return 0;  
}  
```

当上面的代码被编译和执行时，它会产生下列结果：

```
Book 1 title : C Programming
Book 1 author : Nuha Ali
Book 1 subject : C Programming Tutorial
Book 1 book_id : 6495407
Book 2 title : Telecom Billing
Book 2 author : Zara Ali
Book 2 subject : Telecom Billing Tutorial
Book 2 book_id : 6495700
```

### 结构作为函数参数

您可以把结构作为函数参数，传参方式与其他类型的变量或指针类似。您可以使用上面实例中的方式来访问结构变量：

```c
#include <stdio.h>  
#include <string.h>  
  
struct Books  
{  
	char title[50];  
	char author[50];  
	char subject[100];  
	int book_id;  
};  
  
/* 函数声明 */  
void printBook( struct Books book );  
int main( )  
{  
	struct Books Book1; /* 声明 Book1，类型为 Books */  
	struct Books Book2; /* 声明 Book2，类型为 Books */  
	  
	/* Book1 详述 */  
	strcpy( Book1.title, "C Programming");  
	strcpy( Book1.author, "Nuha Ali");  
	strcpy( Book1.subject, "C Programming Tutorial");  
	Book1.book_id = 6495407;  
	  
	/* Book2 详述 */  
	strcpy( Book2.title, "Telecom Billing");  
	strcpy( Book2.author, "Zara Ali");  
	strcpy( Book2.subject, "Telecom Billing Tutorial");  
	Book2.book_id = 6495700;  
	  
	/* 输出 Book1 信息 */  
	printBook( Book1 );  
	  
	/* 输出 Book2 信息 */  
	printBook( Book2 );  
	  
	return 0;  
}  

void printBook( struct Books book )  
{  
	printf( "Book title : %s\n", book.title);  
	printf( "Book author : %s\n", book.author);  
	printf( "Book subject : %s\n", book.subject);  
	printf( "Book book_id : %d\n", book.book_id);  
}  
```

当上面的代码被编译和执行时，它会产生下列结果：

```
Book title : C Programming
Book author : Nuha Ali
Book subject : C Programming Tutorial
Book book_id : 6495407
Book title : Telecom Billing
Book author : Zara Ali
Book subject : Telecom Billing Tutorial
Book book_id : 6495700
```

### 指向结构的指针

您可以定义指向结构的指针，方式与定义指向其他类型变量的指针相似，如下所示：

```c
struct Books *struct_pointer;
```

现在，您可以在上述定义的指针变量中存储结构变量的地址。为了查找结构变量的地址，请把 & 运算符放在结构名称的前面，如下所示：

```c
struct_pointer = &Book1;
```

为了使用指向该结构的指针访问结构的成员，您必须使用 `->` 运算符，如下所示：

```c
struct_pointer->title;
```

让我们使用结构指针来重写上面的实例，这将有助于您理解结构指针的概念：

```c
#include <stdio.h>  
#include <string.h>  
  
struct Books  
{  
	char title[50];  
	char author[50];  
	char subject[100];  
	int book_id;  
};  
  
/* 函数声明 */  
void printBook( struct Books *book );  
int main( )  
{  
	struct Books Book1; /* 声明 Book1，类型为 Books */  
	struct Books Book2; /* 声明 Book2，类型为 Books */  
	  
	/* Book1 详述 */  
	strcpy( Book1.title, "C Programming");  
	strcpy( Book1.author, "Nuha Ali");  
	strcpy( Book1.subject, "C Programming Tutorial");  
	Book1.book_id = 6495407;  
	  
	/* Book2 详述 */  
	strcpy( Book2.title, "Telecom Billing");  
	strcpy( Book2.author, "Zara Ali");  
	strcpy( Book2.subject, "Telecom Billing Tutorial");  
	Book2.book_id = 6495700;  
	  
	/* 通过传 Book1 的地址来输出 Book1 信息 */  
	printBook( &Book1 );  
	  
	/* 通过传 Book2 的地址来输出 Book2 信息 */  
	printBook( &Book2 );  
	  
	return 0;  
}  

void printBook( struct Books *book )  
{  
	printf( "Book title : %s\n", book->title);  
	printf( "Book author : %s\n", book->author);  
	printf( "Book subject : %s\n", book->subject);  
	printf( "Book book_id : %d\n", book->book_id);  
}  
```

当上面的代码被编译和执行时，它会产生下列结果：

```
Book title : C Programming
Book author : Nuha Ali
Book subject : C Programming Tutorial
Book book_id : 6495407
Book title : Telecom Billing
Book author : Zara Ali
Book subject : Telecom Billing Tutorial
Book book_id : 6495700
```

### 结构体大小的计算

C 语言中，我们可以使用 **sizeof** 运算符来计算结构体的大小，**sizeof** 返回的是给定类型或变量的字节大小。

对于结构体，**sizeof** 将返回结构体的总字节数，包括所有成员变量的大小以及可能的填充字节。

以下实例演示了如何计算结构体的大小：

```c
#include <stdio.h>  
	  
struct Person {  
	char name[20];  
	int age;  
	float height;  
};  
  
int main() {  
	struct Person person;  
	printf("结构体 Person 大小为: %zu 字节\n", sizeof(person));  
	return 0;  
}  
```

以上实例中，我们定义了一个名为 Person 的结构体，它包含了一个字符数组 `name`、一个整数 `age` 和一个浮点数 `height`。

在 `main` 函数中，我们声明了一个 Person 类型的变量 `person`，然后使用 `sizeof` 运算符来获取 `person` 结构体的大小。

最后，我们使用 `printf` 函数打印出结构体的大小，输出结果如下：

```
结构体 Person 大小为: 28 字节
```

**注意**：结构体的大小可能会受到编译器的优化和对齐规则的影响，编译器可能会在结构体中插入一些额外的填充字节以对齐结构体的成员变量，以提高内存访问效率。因此，结构体的实际大小可能会大于成员变量大小的总和，如果你需要确切地了解结构体的内存布局和对齐方式，可以使用 `offsetof` 宏和 `attribute((packed))` 属性等进一步控制和查询结构体的大小和对齐方式。

## 共用体

**“共用体”（Union）** 是一种特殊的数据类型，允许您在相同的内存位置存储不同的数据类型。您可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值。共用体提供了一种使用相同的内存位置的有效方式。

想象一下，你有一个神奇的背包，这个背包虽然看起来很小，但是它有一个特别的能力：它可以变成不同类型的包。比如，今天你可能需要它变成一个画板包，因为你要去上美术课；明天你可能需要它变成一个运动包，因为你要去踢足球，这样你就不需要买很多个包，每个包只能做一件事。这个背包就像C语言中的共用体，你可以用一个共用体来存储不同类型的数据，但是在同一时间只能使用其中一种。

在C语言中，共用体可以让不同的数据类型共享同一块内存空间。这就像是你的神奇背包，虽然它只能装一种东西，但是它可以变成不同的包来装不同的东西。

### 定义共用体

为了定义共用体，您必须使用 `union` 语句，方式与定义结构类似，它定义了一个新的数据类型，带有多个成员。union 语句的格式如下：

```c
union [union tag] { 
	member definition; 
	member definition; 
	... 
	member definition; 
} [one or more union variables];
```

`union tag` 是可选的，每个 member definition 是标准的变量定义，比如 int i; 或者 float f; 或者其他有效的变量定义。在共用体定义的末尾，最后一个分号之前，您可以指定一个或多个共用体变量，这是可选的。下面定义一个名为 Data 的共用体类型，有三个成员 i、f 和 str：

```c
union Data { 
	int i; 
	float f; 
	char str[20]; 
} data;
```

现在，Data 类型的变量可以存储一个整数、一个浮点数，或者一个字符串。这意味着一个变量（相同的内存位置）可以存储多个多种类型的数据。您可以根据需要在一个共用体内使用任何内置的或者用户自定义的数据类型。

**共用体占用的内存应足够存储共用体中最大的成员。** 例如，在上面的实例中，Data 将占用 20 个字节的内存空间，因为在各个成员中，字符串所占用的空间是最大的。下面的实例将显示上面的共用体占用的总内存大小：

```c
#include <stdio.h> 
#include <string.h> 

union Data { 
	int i; 
	float f; 
	char str[20]; 
}; 

int main( ) 
{ 
	union Data data; 
	printf( "Memory size occupied by data : %d\n", sizeof(data)); 
	return 0; 
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
Memory size occupied by data : 20
```

### 访问共用体成员

为了访问共用体的成员，我们使用成员访问运算符 `.` 。成员访问运算符是共用体变量名称和我们要访问的共用体成员之间的一个句号。您可以使用 `union` 关键字来定义共用体类型的变量。下面的实例演示了共用体的用法：

```c
#include <stdio.h> 
#include <string.h> 

union Data { 
	int i; 
	float f; 
	char str[20]; 
}; 

int main( ) 
{ 
	union Data data; 
	data.i = 10; 
	data.f = 220.5; 
	strcpy( data.str, "C Programming"); 
	printf( "data.i : %d\n", data.i); 
	printf( "data.f : %f\n", data.f); 
	printf( "data.str : %s\n", data.str); 
	return 0; 
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
data.i : 1917853763
data.f : 4122360580327794860452759994368.000000
data.str : C Programming
```

在这里，我们可以看到共用体的 `i` 和 `f` 成员的值有损坏，因为最后赋给变量的值占用了内存位置，这也是 `str` 成员能够完好输出的原因。现在让我们再来看一个相同的实例，这次我们在同一时间只使用一个变量，这也演示了使用共用体的主要目的：

```c
#include <stdio.h> 
#include <string.h> 

union Data { 
	int i; 
	float f; 
	char str[20]; 
}; 

int main( ) 
{ 
	union Data data; 
	data.i = 10; 
	printf( "data.i : %d\n", data.i); 
	data.f = 220.5; 
	printf( "data.f : %f\n", data.f); 
	strcpy( data.str, "C Programming"); 
	printf( "data.str : %s\n", data.str); 
	return 0; 
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
data.i : 10
data.f : 220.500000
data.str : C Programming
```

在这里，所有的成员都能完好输出，因为同一时间只用到一个成员。

### 应用

共用体在一般的编程中应用较少，在单片机中应用较多。对于 PC 机，经常使用到的一个实例是： 现有一张关于学生信息和教师信息的表格。学生信息包括姓名、编号、性别、职业、分数，教师的信息包括姓名、编号、性别、职业、教学科目。请看下面的表格：

 
| Name | Num | Sex | Profession | Score / Course |
|--|--|--|--|--|
| HanXiaoXiao | 501 | f | s | 89.5 |
| YanWeiMin | 1011 | m | t | math |
| LiuZhenTao | 109 | f | t | English |
| ZhaoFeiYan | 982 | m | s | 95.0 |

f 和 m 分别表示女性和男性，s 表示学生，t 表示教师。可以看出，学生和教师所包含的数据是不同的。现在要求把这些信息放在同一个表格中，并设计程序输入人员信息然后输出。

如果把每个人的信息都看作一个结构体变量的话，那么教师和学生的前 4 个成员变量是一样的，第 5 个成员变量可能是 score 或者 course。当第 4 个成员变量的值是 s 的时候，第 5 个成员变量就是 score；当第 4 个成员变量的值是 t 的时候，第 5 个成员变量就是 course。

经过上面的分析，我们可以设计一个包含共用体的结构体，请看下面的代码：

```c
#include <stdio.h>
#include <stdlib.h>
#define TOTAL 4 //人员总数
struct {
	char name[20];
	int num;
	char sex;
	char profession;
	union {
		float score;
		char course[20];
	} sc;
} bodys[TOTAL];

int main(){
  int i;
  //输入人员信息
  for (i=0; i<TOTAL; i++){
   printf ( "Input info: " );
   scanf ( "%s %d %c %c" , bodys[i].name, &(bodys[i].num), &(bodys[i].sex), &(bodys[i].profession));
   if (bodys[i].profession == 's' ){ //如果是学生
    scanf ( "%f" , &bodys[i].sc.score);
   } else { //如果是老师
    scanf ( "%s" , bodys[i].sc.course);
   }
   fflush (stdin);
  }
  //输出人员信息
  printf ( "\nName\t\tNum\tSex\tProfession\tScore / Course\n" );
  for (i=0; i<TOTAL; i++){
   if (bodys[i].profession == 's' ){ //如果是学生
    printf ( "%s\t%d\t%c\t%c\t\t%f\n" , bodys[i].name, bodys[i].num, bodys[i].sex, bodys[i].profession, bodys[i].sc.score);
   } else { //如果是老师
    printf ( "%s\t%d\t%c\t%c\t\t%s\n" , bodys[i].name, bodys[i].num, bodys[i].sex, bodys[i].profession, bodys[i].sc.course);
   }
  }
  return 0;
}
```

运行结果：

```
Input info: HanXiaoXiao 501 f s 89.5
Input info: YanWeiMin 1011 m t math
Input info: LiuZhenTao 109 f t English
Input info: ZhaoFeiYan 982 m s 95.0

Name                Num       Sex     Profession       Score / Course
HanXiaoXiao     501         f               s                   89.500000
YanWeiMin       1011       m              t                    math
LiuZhenTao      109         f                t                    English
ZhaoFeiYan      982        m              s                   95.000000
```

# typedef

C 语言提供了 `typedef` 关键字，您可以使用它来自定义一种类型。下面的实例为单字节数字定义了一个术语 `BYTE`：

```c
typedef unsigned char BYTE;
```

在这个类型定义之后，标识符 `BYTE` 可作为类型 unsigned char 的缩写，例如：

```c
BYTE  b1, b2;
```

按照惯例，定义时会大写字母（参见 *代码规范*），以便提醒用户类型名称是一个象征性的缩写，但您也可以使用小写字母，如下：

```c
typedef unsigned char byte;
```

这里有个有点难看懂的例子：

```c
typedef int (*fun_ptr)(int,int); 
// 声明一个指向同样参数、返回值的函数指针类型
```

不过细加思考也能理解，其实这就是在声明一个函数指针变量的语句前加了一个 `typedef` 而已，然后这个函数指针 “变量” 就能被当作一种函数指针类型来使用了，像这样：

```c
int calc(int a, int b)
{
	...;
}

// 其他函数中……
fun_ptr p = &calc;
```

**typedef中声明的类型在变量名的位置出现**，理解了这一句，也就很容易使用typedef了。


## 常见用法

`typedef` 的一个常见用法是对结构体使用来定义一个新的数据类型名字，然后使用这个新的数据类型来直接定义结构变量，如下：


```c
#include <stdio.h> 
#include <string.h> 

typedef struct
{ 
	char title[50]; 
	char author[50]; 
	char subject[100]; 
	int book_id; 
} Book; 

int main( ) 
{ 
	Book book; 
	strcpy( book.title, "旺仔人民共和国简史"); 
	strcpy( book.author, "EBAOBAO"); 
	strcpy( book.subject, "历史"); 
	book.book_id = 12345; 
	printf( "书标题 : %s\n", book.title); 
	printf( "书作者 : %s\n", book.author); 
	printf( "书类目 : %s\n", book.subject); 
	printf( "书 ID : %d\n", book.book_id); 
	return 0; 
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
书标题 : 旺仔人民共和国简史
书作者 : EBAOBAO
书类目 : 12345
书 ID : 12345
```

而如果你只是像这样普通的写一个结构体的话：

```c
struct Book
{ 
	char title[50]; 
	char author[50]; 
	char subject[100]; 
	int book_id; 
}; 
```

在声明一个结构体变量时，你就得像：

```c
struct Book book;
```

这样在前面还要写个 `struct` ，那么假如你要声明很多结构体的话，这显然是比用 `typedef` 的要麻烦的。

## typedef vs #define

`#define` 宏定义当然也可以各种数据类型定义别名，与 `typedef` 类似，但是它们有以下几点不同：

-   `typedef` 仅限于为类型定义，`#define` 不仅可以为类型定义别名，也能为数值定义别名，比如您可以定义 1 为 `ONE`。
-   `typedef` 是由编译器执行解释的，`#define` 语句是由预编译器进行处理的。


# 字符串

在 C 语言中，字符串实际上是使用空字符 \0 结尾的一维字符数组。因此，\0 是用于标记字符串的结束。

**空字符（Null character）** 又称结束符，缩写 `NUL`，是一个数值为 0 的控制字符，`\0` 是转义字符，意思是告诉编译器，这不是字符 0，而是空字符。

下面的声明和初始化创建了一个 `RUNOOB` 字符串。由于在数组的末尾存储了空字符 `\0`，所以字符数组的大小比单词 `RUNOOB` 的字符数多一个。

```c
char site[7] = {'R', 'U', 'N', 'O', 'O', 'B', '\0'};
```

依据数组初始化规则，您可以把上面的语句写成以下语句：

```c
char site[] = "RUNOOB";
```

以下是 C/C++ 中定义的字符串的内存表示：

![C/C++ 中的字符串表示](https://www.runoob.com/wp-content/uploads/2014/09/c-strings-2020-12-21.png)

其实，您不需要把 null 字符放在字符串常量的末尾。C 编译器会在初始化数组时，自动把 \0 放在字符串的末尾。让我们尝试输出上面的字符串：

```c
#include <stdio.h> 
int main() 
{ 
	char site[7] = {'R', 'U', 'N', 'O', 'O', 'B', '\0'}; 
	printf("菜鸟教程: %s\n", site ); 
	return 0; 
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
菜鸟教程: RUNOOB
```

## 再谈字符串字面量

所谓 **字符串字面量** 指的也就是双引号加上里面包的东西，我们已经知道 `"..."` 跟 `{'.', '.', '.', '\0'}` 没什么区别。

这里要注意的是，我们先前也提到过，字符串字面量是个不可修改的左值，相当于一个常量，它本身是存储在程序的只读数据段的，尝试修改字符串字面量中的字符是不允许的，因为这会导致未定义行为。字符串字面量存储在程序的只读数据段，尝试修改它们会导致程序崩溃，也就是说你不能写出类似于

```c
"Hello, World!"[0] = 'h';
```

这样的代码。

这看起来有些匪夷所思——我干嘛要写出这样的代码，我什么情况下会写出这样的代码？好吧，我们当然不会写出这样的代码，不过我的意思是说我们很有可能犯一些类似的错误，比方说，我们说字符串字面量相当于一个字符数组，于是我们声明一个变量后再装字符串就有可能就会像这样：

```c
char *str = "Hello, World!";
str[0] = 'h';  // 这是未定义行为
```

***这样就是不行的！*** 这里指针 `str` 指向了字符串的底层地址，那么这里就跟上面那种写法实质上没有区别！

不过

```c
char c[1001];
c = "Hello, World!";
```

我们说数组名是个不可修改的左值，要是直接像这样赋值，就相当于 c 指向了只读数据段中 `"Hello, World!"` 这个字符串字面量的地址，而你不能给一个不可修改的左值重新赋值，这就是一个语法错误！


不过这下问题就来了，我们又可以使用 `char site[] = "EBAOBAO"` 这样的语句来声明一个字符数组，为什么这样又是可行的呢？

事实上，当你执行 `char site[] = "EBAOBAO";` 时，是在内存中开辟了一个新的字符数组 `site`，并将字符串字面量 `"EBAOBAO"` 中的每个字符（包括结尾的空字符 `'\0'`）复制到这个数组中。这样，`site` 数组就包含了字符串 `"EBAOBAO"` 的一个 **副本** 。这时字符串字面量 `"EBAOBAO"` 本身存储在程序的只读数据段。然而，当你修改 `site` 数组中的字符时，你并没有修改字符串字面量。**你实际上是在修改 `site` 数组中的副本，这是完全合法和安全的！**

所以，这样写就也是可以的：

```c
#include <string.h>

char c[1001];
strcpy(c, "Hello, World!");
```

至于 `strcpy` 这个函数的用法如何，后文有详细说明。


## string.h

C 中还有大量操作字符串的函数，你可以通过引入 *string .h* 头文件来使用它们：

`strcpy(s1, s2)`
: 复制字符串 s2 到字符串 s1。

**注意使用这个函数时，s2 的长度不能超过 s1, 否则将导致缓冲区溢出，可能会覆盖重要的内存区域，造成安全问题。**

不过可以使用 `strncpy` 函数来解决这个问题，它能限制复制的字符数。

`strncpy(s1, s2, len)`
: 复制字符串 s2 到字符串 s1，不过最多复制 len 个字符。

```c
#include <stdio.h>
#include <string.h>

int main()
{
    char s[10] = "12345", t[] = "6543d21"; // 确保s有足够的空间
    strncpy(s, t, sizeof(s) - 1); // 复制t到s，最多复制sizeof(s) - 1个字符
    s[sizeof(s) - 1] = '\0'; // 确保字符串以'\0'结尾
    printf("%s", s);
    return 0;
}
```

`strcat(s1, s2)`
: 连接字符串 s2 到字符串 s1 的末尾。

`strlen(s1)` 
: 返回字符串 s1 的长度。

`strcmp(s1, s2)`
: 如果 s1 和 s2 是相同的，则返回 0；如果 s1<s2 则返回小于 0；如果 s1>s2 则返回大于 0。

`strchr(s1, ch)` 
: 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。

`strstr(s1, s2)`
: 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。

下面的实例使用了上述的一些函数：

```c
#include <stdio.h> 
#include <string.h> 
int main () 
{ 
	char str1[14] = "runoob"; 
	char str2[14] = "google"; 
	char str3[14]; 
	int len ; 
	
	/* 复制 str1 到 str3 */ 
	strcpy(str3, str1); 
	printf("strcpy( str3, str1) : %s\n", str3 ); 
	
	/* 连接 str1 和 str2 */ 
	strcat( str1, str2); 
	printf("strcat( str1, str2): %s\n", str1 ); 
	
	/* 连接后，str1 的总长度 */ 
	len = strlen(str1); 
	printf("strlen(str1) : %d\n", len ); 
	
	return 0; 
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
strcpy( str3, str1) :  runoob
strcat( str1, str2):   runoobgoogle
strlen(str1) :  12
```

您可以在 C 标准库中找到更多字符串相关的函数。

# 文件读写

## 基本概念

数据流
: 就C程序而言，从程序移进，移出字节，这种字节流就叫做流。简单地说，**它像流水线上的传送带，可以将文件中的数据传到程序中，也能将程序处理后的数据传到文件中去，而且它必须得动起来才能实现这些操作。也可以将它想象成送外卖的骑手之类的**。 程序与数据的交互是以流的形式进行的。进行C语言文件的读写时，都会先进行“打开文件”操作，这个操作就是在打开数据流，而“关闭文件”操作就是关闭数据流。

缓冲区
: 在程序执行时，所提供的额外内存，可用来暂时存放准备执行的数据。它的设置是为了提高存取效率，因为内存的存取速度比磁盘驱动器快得多。

: 当使用标准I/O函数(包含在头文件 *stdio.h* 中)时，系统会自动设置缓冲区，并通过数据流来读写文件。当进行文件读取时，是先打开数据流，将磁盘上的文件信息拷贝到缓冲区内，然后程序再从缓冲区中读取所需数据。事实上，当写入文件时，并不会马上写入磁盘中，而是先写入缓冲区，只有在缓冲区已满或“关闭文件”时，才会将数据写入磁盘。

文件类型
: 文本文件和二进制文件：
: 文本文件是以字符编码的方式进行保存的。
: 二进制文件将内存中的数据原封不动的进行保存，适用于非字符为主的数据。其实，所有的数据都可以算是二进制文件。二进制文件的优点在于存取速度快，占用空间小。

文件存取方式
: 顺序存取方式和随机存取方式：
: 顺序存取就是从上往下，一笔一笔读取文件的内容。写入数据时，将数据附加在文件的末尾。这种存取方式常用于文本文件。
: 随机存取方式多半以二进制文件为主。它会以一个完整的单位来进行数据的读取和写入，通常以结构为单位。

## C 语言中的文件

文件是一段数据的集合，这些数据可以是有规则的，也可以是无序的集合。在stdio.h有一个非常重要的东西，文件指针，每个文件都会在内存中开辟一块空间，用于存放文件的相关信息，这些信息保存在一个结构体中：

```c
struct _iobuf {
	char *_ptr; //指向buffer中第一个未读的字节
	int _cnt; //记录剩余的未读字节的个数
	char *_base;//文件的缓冲
	int _flag;//打开文件的属性
	int _file;//获取文件描述
	int _charbuf;//单字节的缓冲，即缓冲大小仅为1个字节
	int _bufsiz;//记录这个缓冲大小
	char *_tmpfname;//临时文件名
};
typedef struct _iobuf FILE;
```

FILE是一个数据结构，用于访问一个流。每个流都会对应一个FILE结构体。


## 打开文件

您可以使用 `fopen()` 函数来创建一个新的文件或者打开一个已有的文件，这个调用会初始化类型 FILE 的一个对象，类型 FILE 包含了所有用来控制流的必要的信息。下面是这个函数调用的原型：

```c
FILE *fopen( const char *filename, const char *mode );
```

在这里，`filename` 是文件名，访问模式 `mode` 的值可以是下列值中的一个：

| 模式 | 描述 |
|--|--|
| r | 打开一个已有的文本文件，允许读取文件。 |
| w | 打开一个文本文件，允许写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会从文件的开头写入内容。如果文件存在，则该会被截断为零长度，重新写入。 |
| a | 打开一个文本文件，以追加模式写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会在已有的文件内容中追加内容。 |
| r+ | 打开一个文本文件，允许读写文件。 |
| w+ | 打开一个文本文件，允许读写文件。如果文件已存在，则文件会被截断为零长度，如果文件不存在，则会创建一个新文件。 |
| a+ | 打开一个文本文件，允许读写文件。如果文件不存在，则会创建一个新文件。读取会从文件的开头开始，写入则只能是追加模式。 |

如果处理的是二进制文件，则需使用下面的访问模式来取代上面的访问模式：

```
"rb", "wb", "ab", "rb+", "r+b", "wb+", "w+b", "ab+", "a+b"
```

## 关闭文件

为了关闭文件，请使用 fclose( ) 函数。函数的原型如下：

```c
int fclose( FILE *fp );
```

如果成功关闭文件，`fclose()` 函数返回零，如果关闭文件时发生错误，函数返回 `EOF`。这个函数实际上，会清空缓冲区中的数据，关闭文件，并释放用于该文件的所有内存。EOF 是一个定义在头文件 *stdio.h* 中的常量。

C 标准库提供了各种函数来按字符或者以固定长度字符串的形式读写文件。

## 写入文件

下面是把字符写入到流中的最简单的函数：

```c
int fputc( int c, FILE *fp );
```

函数 `fputc()` 把参数 c 的字符值写入到 fp 所指向的输出流中。如果写入成功，它会返回写入的字符，如果发生错误，则会返回 `EOF`。您可以使用下面的函数来把一个以 null 结尾的字符串写入到流中：

```c
int fputs( const char *s, FILE *fp );
```

函数 `fputs()` 把字符串 s 写入到 fp 所指向的输出流中。如果写入成功，它会返回一个非负值，如果发生错误，则会返回 `EOF`。您也可以使用 `int fprintf(FILE *fp,const char *format, ...)` 函数把一个字符串写入到文件中。尝试下面的实例：

> **注意：** 请确保您有可用的 tmp 目录，如果不存在该目录，则需要在您的计算机上先创建该目录。
> 
> /tmp 一般是 Linux 系统上的临时目录，如果你在 Windows 系统上运行，则需要修改为本地环境中已存在的目录，例如: C:\tmp、D:\tmp等。

```c
#include <stdio.h> 
int main() 
{ 
	FILE *fp = NULL; 
	fp = fopen("E://tmp/test.txt", "w+"); 
	fprintf(fp, "This is testing for fprintf...\n"); 
	fputs("This is testing for fputs...\n", fp); 
	fclose(fp); 
}
```

当上面的代码被编译和执行时，它会在 /tmp 目录中创建一个新的文件 *test.txt*，并使用两个不同的函数写入两行。接下来让我们来读取这个文件。

## 读取文件

下面是从文件读取单个字符的最简单的函数：

```c
int fgetc( FILE * fp );
```

`fgetc()`函数从 fp 所指向的输入文件中读取一个字符。返回值是读取的字符，如果发生错误则返回 `EOF`。下面的函数允许您从流中读取一个字符串：

```c
char *fgets( char *buf, int n, FILE *fp );
```

函数 `fgets()` 从 fp 所指向的输入流中读取 n - 1 个字符。它会把读取的字符串复制到缓冲区 buf，并在最后追加一个 null 字符来终止字符串。

如果这个函数在读取最后一个字符之前就遇到一个换行符 '\n' 或文件的末尾 EOF，则只会返回读取到的字符，包括换行符。您也可以使用 `int fscanf(FILE *fp, const char *format, ...)` 函数来从文件中读取字符串，但是在遇到第一个空格和换行符时，它会停止读取。

```c
#include <stdio.h> 
int main() 
{ 
	FILE *fp = NULL; 
	char buff[255]; 
	fp = fopen("/tmp/test.txt", "r"); 
	fscanf(fp, "%s", buff); 
	printf("1: %s\n", buff ); 
	fgets(buff, 255, (FILE*)fp); 
	printf("2: %s\n", buff ); 
	fgets(buff, 255, (FILE*)fp); 
	printf("3: %s\n", buff ); 
	fclose(fp); 
}
```

当上面的代码被编译和执行时，它会读取上一部分创建的文件，产生下列结果：

```
1: This
2: is testing for fprintf...

3: This is testing for fputs...
```

首先，`fscanf()` 只读取了 `This`，因为它在后边遇到了一个空格。其次，调用 `fgets()` 读取剩余的部分，直到行尾。最后，调用 `fgets()` 完整地读取第二行。

## `freopen()` 重定向标准输入输出

`FILE *freopen( const char *path, const char *mode, FILE *stream );`
: 实现重定向，把预定义的标准流文件定向到由path指定的文件中。

标准流文件具体是指stdin、stdout和stderr。其中stdin是标准输入流，默认为键盘；stdout是标准输出流，默认为屏幕；stderr是标准错误流，一般把屏幕设为默认。

`scanf()` 或 `printf()` 之类的输入输出函数本来其实也就是读写这些标准流文件的，所以只要用了 `freopen()` 后，就可以直接使用这些输入输出函数来读写我们想读写的文件了！！

使用例：

```c
#include <stdio.h>

int main() 
{ 
	int a,b; 
	freopen("D:\\in.txt","r",stdin); //输入重定向，输入数据将从D盘根目录下的in.txt文件中读取 
	freopen("D:\\out.txt","w",stdout); //输出重定向，输出数据将保存在D盘根目录下的out.txt文件中 
	while(scanf("%d %d",&a,&b)!=EOF) 
		printf("%d\n",a+b); 
	fclose(stdin);//关闭重定向输入 
	fclose(stdout);//关闭重定向输出 
	return 0; 
} 
```

正如上文所说，`freopen("D:\\in.txt","r",stdin)` 的作用就是把标准输入流stdin重定向到 *D:\\in.txt* 文件中，这样在用 `scanf` 输入时便不会从标准输入流读取数据,而是从 *in.txt* 文件中获取输入。只要把输入数据事先粘贴到 *in.txt* 中即可。

类似的，`freopen("D:\\out.txt","w",stdout)` 的作用就是把 stdout 重定向到 *D:\\out.txt* 文件中，这样输出结果就可以通过打开out.txt文件查看。

# 错误处理

在编写程序的过程中，我们会遇到种种错误。有时我们可能打错代码，犯一些语法错误，这样的错误会在编译时就会报错，而且在文本编辑器中就会爆红，所以我们很快就能检查出来并修改，但假如我们遇到

-   文件未找到错误
-   网络连接错误
-   无效的用户输入
-   内存不足错误
-   除以零错误
-   数组越界错误
-   类型不匹配错误

等 *运行时错误* 的话，整个程序就会立刻崩溃。而通过 **错误处理**，程序就可以优雅地处理异常情况，而不是在遇到错误时崩溃。这提高了程序的稳定性和可靠性。

错误处理就是指在程序运行时对可能出现的错误或异常情况进行检测和处理的机制。C 语言中常用的错误处理技术包括：

1. 返回值检查：可以通过函数的返回值来判断函数执行是否成功，如果返回的状态码表示出现了错误则需要进行相应的处理。
2. 模拟异常处理：C 语言没有内置的异常处理机制，但是可以通过 `setjmp()` 和`longjmp()`等函数来实现类似异常处理的功能。
3. 断言函数：断言函数（如 `assert()`）可以在程序运行时检查某个条件是否成立，如果不成立就会终止程序并输出错误信息。


## 返回值检查

**C 语言不提供对错误处理的直接支持，但是作为一种系统编程语言，它以返回值的形式允许您访问底层数据。** 在发生错误时，大多数的 C 或 UNIX 函数调用返回 1 或 NULL，同时会设置一个错误代码 `errno`，该错误代码是全局变量，表示在函数调用期间发生了错误，不同错误代码值表示不同错误，也有不同的文本表示形式，比如代码 2 的文本表示就是 `"No such file or directory"`，说明程序找不到你指定的文件或目录。您可以在 *errno.h* 头文件中找到各种各样的错误代码。

所以，C 程序员可以通过检查返回值，然后根据返回值决定采取哪种适当的动作。开发人员应该在程序初始化时，把 errno 设置为 0，这是一种良好的编程习惯（0 值表示程序中没有错误）。

C 语言提供了 `perror()` 和 `strerror()` 函数来显示与 `errno` 相关的文本消息。

`void perror(const char *_ErrMsg)` 
: 显示你传给它的字符串，后跟一个冒号、一个空格和当前 errno 值的文本表示形式。

`char * strerror(int)` 
: 返回一个字符指针，指针指向传入的 errno 值的文本表示形式。

让我们来模拟一种错误情况，尝试打开一个不存在的文件。您可以使用多种方式来输出错误消息，在这里我们使用函数来演示用法。**另外有一点需要注意，您应该使用 *stderr* 文件流来输出所有的错误。**

```c
#include <stdio.h> 
#include <errno.h> 
#include <string.h> 

extern int errno ; 

int main () 
{ 
	FILE * pf; 
	int errnum; 
	pf = fopen ("unexist.txt", "rb"); 
	
	if (pf == NULL) 
	{ 
		errnum = errno; 
		fprintf(stderr, "错误号: %d\n", errno); 
		perror("通过 perror 输出错误"); 
		fprintf(stderr, "打开文件错误: %s\n", strerror( errnum )); 
	} 
	
	else 
	{ 
		fclose (pf); 
	} 
	return 0; 
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```
错误号: 2
通过 perror 输出错误: No such file or directory
打开文件错误: No such file or directory
```

## 模拟异常处理

如果你学过 C++ 或是 Java 这类语言的话，你会知道它们会有 `try-catch` 这样用于异常处理的语句，C 语言中没有这种东西，不过在C语言中可以引用 *setjmp.h* 头文件并使用 `setjmp()` 和 `longjmp()` 函数组合来模拟异常处理机制。

`int setjmp(jmp_buf Buf)`
: 用于保存当前程序的上下文，以便之后可以通过 `longjmp` 恢复。

`void longjmp(jmp_buf Buf, int Value)`
: 用于跳转到之前由 `setjmp` 保存的上下文。

……呃，这看起来有点难以理解，现在就来细致地讲解一下：

首先你注意到这两个函数都有 `jmp_buf` 类型的参数，`jmp_buf` 是一个特殊的数据类型，用于存储程序的执行状态（上下文）。当你调用 `setjmp()` 函数时，它会保存当前程序的执行状态，包括程序计数器、栈指针等信息。这样，你可以在以后恢复到这个状态。

可以把 `jmp_buf` 变量想象成一个游戏中的一个存档档位，它记录了你在某个游戏中时刻的所有重要信息，以便你可以在需要的时候返回到那个时刻。

而 `setjmp()` 函数用于保存当前的执行状态到 `jmp_buf` 变量中，也就是实现 “存档” 的操作，调用这个函数的 “时间点” 也是 `longjmp()` 函数跳回的 “时间”。当你调用 `setjmp(exception_buffer)` 时，它会把当前的状态保存到 `exception_buffer` 中，并返回一个值（通常是 0 或 `longjmp()` 函数携带的 `value` ）。**这个值可以用来判断程序是正常执行还是因为调用了 `longjmp()` 返回的，我们其实也就是通过判断这个值是否为 0 来实现异常处理的。**

相对的，`longjmp()` 函数也就是用来 “读档” 的。当你调用 `longjmp(exception_buffer, value)` 时，程序会跳回到之前调用 `setjmp()` 的地方，并且 `setjmp()` 会返回你传递的 `value`（通常是非零值）。

也就是说，我们这样使用这两个函数：

```c
if (setjmp(exception_buffer) == 0) {
    // 正常执行的代码
    if (...) //如果检测到异常……
    {
		...; //就可以先输出个异常信息什么的
		longjmp(exception_buffer, 1); 
		//……然后跳回setjmp那里去，并让setjmp返回1表示出现了异常
	}
} else {
    // 处理异常的代码
}
```

至于怎么检测异常，呃，其实还是判断一些函数的返回值或是代码中是否出现什么逻辑错误之类的……

```c
#include <stdio.h>
#include <setjmp.h>

jmp_buf exception_buffer;
void catch_exception(const char *msg)
{
    printf("Exception caught: %s", msg);
    longjmp(exception_buffer, 1);
}

void complex_operation()
{
    int a = 5, b = 0;
    if(b == 0)
	    catch_exception("Division by zero");    
    else        
	    printf("Result: %d", a/b);  
}

int main()
{
   if(setjmp(exception_buffer) == 0)
	   complex_operation();    
   else        
	   printf("Program terminated due to exception");
   return 0;
}
```

好吧，其实本质上还是返回值检查，只不过使用它实现的错误处理的语法结构比较类似于 `try-catch` 而已。

## 断言函数

断言函数（Assertion function）是一种程序设计中用于进行错误检查和调试的技术。

断言函数是一个布尔表达式，用于指示在运行时某个条件是否成立。如果这个条件不成立，程序就会抛出异常或者中断运行，并输出相关的错误信息。

在 Android 程序中，断言函数通常被用于进行**参数合法性检查、空指针检查**等操作，以防止程序因为非法输入或者其他原因而导致崩溃或者异常行为。

在 C 中，常见的断言函数是`assert()` 函数（要引用 *assert.h* 头文件）：

`assert()` 函数是一个宏，它用于检查一个条件是否为真。如果条件为假（即 `assert` 失败），`assert()` 会打印一条错误信息，并终止程序。这个宏通常用于调试阶段，以确保某些重要的条件（如数组索引在合法范围内）为真。

用法：

```c
#include <assert.h>

void func(int value) {
    assert(value >= 0);  // 检查 value 是否非负
    // ... 其他代码 ...
}

int main() {
    func(-1);  // 这将触发断言失败，因为 -1 小于 0
    return 0;
}
```

在上面的例子中，当 `func()` 被调用时，如果 `value` 小于 0，`assert()` 会失败，并打印一条错误信息。

下面是一个使用 `assert()` 函数进行调试的示例代码：

```c
#include <stdio.h>
#include <assert.h>
int main()
{
    int x = 5;    int y = 10;
    assert(x < y);  // 检查 x 是否小于 y
    printf("x + y = %d\n", x + y);
    return 0;
}
```

在上述代码中，使用了 assert() 函数来检查变量 x 是否小于变量 y。由于 x < y 的条件成立，程序不会抛出异常，因此可以正常运行并输出 "x + y = 15" 的结果。

如果我们将 x 和 y 的值交换一下，使x > y，则程序会在执行到 assert() 函数时抛出一个异常，并输出相关的错误信息：

```
Assertion failed: x < y, file test.c, line 9
```

这个错误提示告诉我们，在文件 test.c 的第 9 行处，断言 x < y 失败了，即 x 的值大于等于 y 的值。这就可以帮助我们快速找到代码中的问题，并进行修复。

## 程序退出状态

不知道各位有没有思考过一个问题，就是我们最常用的 `main()` 函数为什么是要返回 int 类型的？这个 int 类型的值又有什么含义？

事实上，其原因与 C 语言的历史和兼容性有关。在早期的 Unix 操作系统中，**程序的退出状态** 是通过返回一个整数来实现的，这个整数被用来表示程序是否正常结束（通常返回 0）或者因为某种错误而结束（返回非零值）。这个退出状态可以被操作系统捕获，并用于后续的处理，比如脚本或批处理文件可以根据程序的返回值来决定下一步的操作。

因此，`main` 函数返回的 `int` 值通常被用来表示程序的退出状态。按照惯例：

-   返回 `0` 通常表示程序成功执行并正常结束。
-   返回非零值通常表示程序在执行过程中遇到了错误或异常，并因此提前终止。

通常情况下，程序成功执行完一个操作正常退出的时候会带有值 `EXIT_SUCCESS`。在这里，`EXIT_SUCCESS` 是宏，它被定义为 0。而如果程序中存在一种错误情况，当您退出程序时，会带有状态值 `EXIT_FAILURE`，被定义为 -1（使用这两个宏要引入 *stdlib.h* 头文件）。

这个约定使得程序可以被其他程序（如 shell 脚本）用来判断其执行结果，并据此做出相应的处理。例如，在 Unix 和 Linux 系统中，你可以使用 `$?` 变量来检查上一个命令的退出状态。

此外，`main` 函数也可以返回其他值，这些值通常用于表示更具体的退出原因，但这些值并没有固定的含义，它们完全取决于程序的设计和约定。在某些系统中，可能会定义一些标准的退出代码，但这些并不是 C 语言标准的一部分，而是由特定的应用程序或操作系统定义的。


理解这一点，我们就可以利用它来在一些可能出错的地方生成错误信息并终止程序，比如在进行除法运算时，如果不检查除数是否为零，则会导致一个运行时错误。为了避免这种情况发生，下面的代码在进行除法运算前会先检查除数是否为零：

```c
#include <stdio.h> 
#include <stdlib.h> 

int main() 
{ 
	int dividend = 20; 
	int divisor = 0; 
	int quotient; 
	if( divisor == 0)
	{ 
		fprintf(stderr, "除数为 0 退出运行...\n"); 
		exit(-1); 
	} 
	quotient = dividend / divisor; 
	fprintf(stderr, "quotient 变量的值为 : %d\n", quotient ); 
	exit(0); 
}
```

噢，这里出现了我们没提到过的函数：

`void exit(int _Code)`
: 关闭所有文件，终止正在执行的进程，其参数会被传递给一些操作系统。
: 所在头文件：*stdlib.h*
: `exit(0)` 表示正常退出，`exit(x)`（x不为0）都表示异常退出。

当上面的代码被编译和执行时，它会产生下列结果：

```
除数为 0 退出运行...
```

当然，上面的代码中也可以用 `EXIT_SUCCESS` 来替换参数 0、用 `EXIT_FAILURE` 替换参数 -1，这样可读性会更强。



